{"pages":[{"title":"About Me","text":"","link":"/about/index.html"}],"posts":[{"title":"Sort","text":"Javascript sort1. Bubble Sort버블정렬은 두 인접한 원소의 크기를 비교하여 정렬하는 방법 O(n) 123456789101112131415function bubble(arr) { let result = arr.slice(); for (let i = 0; i &lt; result.length - 1; i++) { // 한번 순외하면 result 가장 끝에 큰수가 정렬되므로 -i for (let j = 0; j &lt; result.length - i; j++) { if (result[j] &gt; result[j + 1]) { let temp = result[j]; result[j] = result[j + 1]; result[j + 1] = temp; } } } return result;} 2. Merge Sort 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. 123456789101112131415161718192021222324252627282930313233function mergeSort(arr) { if (arr.length &lt;= 1) return arr; const mid = Math.floor(arr.length / 2); const left = arr.slice(0, mid); let right = arr.slice(mid); return merge(mergeSort(left), mergeSort(right));}function merge(left, right) { let result = []; while (left.length &amp;&amp; right.length) { if (left[0] &lt; right[0]) { result.push(left.shift()); } else { result.push(right.shift()); } } while (left.length) { result.push(left.shift()); } while (right.length) { result.push(right.shift()); } return result;}let arr = [4, 1, 5, 3, 2, 6, 7];console.log(arr);console.log(mergeSort(arr)); 3. Quck Sort기준값을 두고 작으면 왼쪽 크면 오른쪽으로 이동시키는 것을 반복한다. 123456789101112131415161718192021unction quckSort(arr) { if (arr.length &lt;= 1) return arr; let pivot = arr[0]; let left = []; let right = []; for (let i = 1; i &lt; arr.length; i++) { if (pivot &gt; arr[i]) { left.push(arr[i]); } else { right.push(arr[i]); } } return quckSort(left).concat(pivot, quckSort(right));}const arr = [4, 1, 5, 3, 2, 6, 7];console.log(arr);console.log(quckSort(arr));","link":"/2020/06/22/algorithm/2020-06-22-sort/"},{"title":"Java HashMap","text":"HashMap 2차원 배열 형태 (다른 언어의 Dictionary) Key, Value 의 쌍으로 이루어져 있다. null Key, value 를 허용한다. Key 의 중복을 허용하지 않고 Value는 중복이 가능하다. 동기화를 지원하지 않는다. 주요 메소드 1234567891011121314151617181920Map&lt;String, String&gt; hm = new HashMap();hm.put(&quot;key&quot;, &quot;value&quot;); // key, value 저장hm.get(&quot;key&quot;) // key로 value 호출hm.remove(&quot;key&quot;) // key로 삭제hm.isEmpty() // hm이 비어있는지 확인Set&lt;String&gt; keys = hm.keySet(); // Key를 set에 리턴for (String key : keys) { System.out.println(&quot;key: &quot; + key);}Collection&lt;String&gt; values = hm.values(); // value를 Collection 으로 리턴for (String value : values) { System.out.println(&quot;value: &quot; + value);}hm.containsKey(&quot;key&quot;); // hm에 key가 있는지 확인hm.containsValue(&quot;value&quot;); //hm에 value가 있는지 확인hm.replace(&quot;key&quot;, &quot;newValue&quot;); //hm의 value를 변경hm.replace(&quot;key&quot;, &quot;oldValue&quot;, &quot;newValue&quot;); //hm의 oldvalue가 일치 하면 value를 변경 HashMap.forEach() 123456789101112131415Map&lt;String, String&gt; hm = new HashMap();hm.put(&quot;key1&quot;, &quot;value1&quot;); // key, value 저장hm.put(&quot;key2&quot;, &quot;value2&quot;); // key, value 저장hm.put(&quot;key3&quot;, &quot;value3&quot;); // key, value 저장//함수형 인터페이스(Functional Interface) 람다식(Lambda Expressions)hm.forEach((key, value) -&gt; System.out.println(&quot;key: &quot; + key + &quot;, value: &quot; + value));hm.entrySet().forEach((entry) -&gt; System.out.println( &quot;key: &quot; + entry.getKey() + &quot;, value: &quot; + entry.getValue()));hm.keySet().forEach((key) -&gt; System.out.println(&quot;key: &quot; + key));hm.values().forEach((value) -&gt; System.out.println(&quot;value: &quot; + value));","link":"/2020/06/29/java/2020-06-29-java-hashmap/"},{"title":"Search Algorithms (Linear , Binary)","text":"검색 알고리즘은 데이터 구조에 저장된 요소를 확인하기 위해서 디자인된 알고리즘이다. 검색 유형에 따라서 알고리즘은 두 가지로 분류된다. Sequential Search : 리스트나 배열을 차례대로 순회 하면서 모든 요소를 체크하는 방법. Linear Search 선형 검색이 해당한다. Interval Search : 정렬된 데이터 구조에서 활용하는 알고리즘으로 검색 하는 데이터 구조를 분할하여 찾기 때문에 Linear Search 보다 효율적이다. Linear Search (선형 검색) 두가지 조건 중에 하나가 만족되면 알고리즘을 종료한다. 조건 1. 검색할 값을 발견하지 못하고 배열이 끝나는 경우 조건 2. 검색할 값과 같은 요소를 발견한 경우 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;public class SeqSearch {/*While 로 구현할 경우static int seqSearch(int[] a, int n, int key){ int i = 0; while (true){ //무한 루브 생성 if(i == n){ return -1; // 조건 1 } if(a[i] == key){ //조건 2 return i; } i++; } } */ static int seqSearch(int[] a, int n, int key) { for (int i = 0; i &lt; n; i++){ // 배열의 숫자만큼 반복 if(a[i] == key) // 조건 1 return i; } return -1; // 조건 2 } public static void main(String[] args) { Scanner stdIn = new Scanner(System.in); System.out.println(&quot;요소수 : &quot; ); int num = stdIn.nextInt(); int[] x = new int[num]; for (int i = 0; i &lt; num; i++){ System.out.println(&quot;[ x&quot; + i + &quot;]:&quot;); x[i] = stdIn.nextInt(); } System.out.println(&quot;검색할 값: &quot;); int ky = stdIn.nextInt(); int idx = seqSearch(x, num, ky); if(idx == -1) { System.out.println(&quot;검색한 요소가 없습니다.&quot;); }else{ System.out.println(ky+&quot;은 x[&quot;+idx+&quot;]에 있습니다.&quot;); } }} 조건 1 과 조건 2를 모두 판단하려면 두개의 조건을 모두 반복해서 판단해야 한다.이보다 효율적인 방법은 보초법(Sentinel method) 이다. 검색하려고 하는 값을 배열의 맨끝의 요소로 추가하여 저장하고 원하는 값을 확인하다.원래의 배열에 값이 존재하지 않아도 마지막에 보초를 만나면 조건 1에 속한다. 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Scanner;//선형 검색 보초법public class SeqSearchSentinel { static int seqSearch(int[] a, int n , int key){ int i = 0; a[n] = key; //보초 저장 공간에 저장한다. while (true){ if(a[i] == key) //조건 2를 판단한다. break; i++; } return i == n ? -1 : i; //조건 1 을 판단한다. } public static void main(String[] args) { Scanner stdIn = new Scanner(System.in); System.out.print(&quot;요솟수：&quot;); int num = stdIn.nextInt(); int[] x = new int[num + 1]; //보초를 저장하기 위한 공간 확보 for (int i = 0; i &lt; num; i++){ System.out.println(&quot;x[&quot; + i +&quot;]:&quot;); x[i] = stdIn.nextInt(); } System.out.println(&quot;검색할 값: &quot;); int ky = stdIn.nextInt(); int idx = seqSearch(x, num, ky); if(idx == -1) System.out.println(&quot;찾는 요소가 없습니다&quot;); else System.out.println(ky +&quot;은 x[&quot; + idx + &quot;]에 있습니다.&quot;); }} Binary Search (이진 검색) 전제 조건은 데이터의 값이 오름차순 또는 내림차순으로 이미 정렬(Sort)된 배열을 검색한다.배열의 시작 인덱스 , 배열의 중앙 인덱스 , 배열의 마지막 인덱스를 가지고 이진 검색을 수행한다. 이진 검색 알고리즘의 종료 조건은 다음과 같다. 조건 1. 중앙 인덱스가 키와 일치하는 경우 조건 2. 검색 범위가 더이상 없는 경우 123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;public class BinSearch { static int binSearch(int[] a, int n, int key){ int l = 0; //시작 인덱스로 초기화 int r = n -1; //마지막 인덱스로 초기화 do{ int m = (l + r) / 2; // 중앙 인덱스의 값으로 초기화 if(a[m] == key){ return m; } else if (a[m] &lt; key){ l = m + 1; } else { r = m - 1; } } while (l &lt;= r); //검색 범위가 남아 있다면 return -1; } static int binSearchWhile(int[] a, int n, int key) { int l = 0; //시작 인덱스로 초기화 int r = n -1; //마지막 인덱스로 초기화 while(l &lt;= r){ int m = ( l + r ) / 2; if(a[m] == key) return 1; if(a[m] &lt; key) l = m + 1; else r = m - 1; } return -1; }}","link":"/2020/09/28/algorithm/2020-09-28-searchAlgorithms/"},{"title":"Java - startsWith(), endsWith()","text":"String Class Method 중 에 접두어/접미어를 확인하는 알고리즘 문제풀이에서 확인필요에 따라 사용 startsWith() - 접두어 일치 여부를 boolen으로 리턴(대소문자를 구별함)1234567String str = &quot;java&quot;;boolen startsWith = str.startsWith(&quot;j&quot;);boolen notStartWith = str.startsWith(&quot;a&quot;);System.out.println(starstWith);System.out.println(notStartsWith); endsWith() - 접미어 일치 여부를 boolen으로 리턴(대소문자를 구별함)1234567String str = &quot;java&quot;;boolen endWith = str.endsWith(&quot;j&quot;);boolen notEndWith = str.endsWith(&quot;a&quot;);System.out.println(endsWith);System.out.println(notEndsWith);","link":"/2020/07/01/java/2020-07-01-java-String-method/"},{"title":"Java 8 Specific Features","text":"JAVA 1.8 자바버전 중에 가장 큰 변화를 가져왔고 많은 프로젝트에서 지금도 많이 쓰이고 있는 버전이다. 람다 표현식(Lambda Expression) 메서드 명과 반환값을 적지 않아도 작동되는 표현식 (Anonymous Function) 1234567891011121314151617반환타입 메서드이름 (매개변수 선언) {}~~반환타입 메서드이름~~ () -&gt; {}int max(int a, int b) { return a &gt; b ? a : b; }~~int max~~int max(int a, int b) -&gt; { return a &gt; b ? a : b; }(int a, int b) -&gt; { return a &gt; b ? a : b; } //retrun 문일 경우 {} 생략 불가(int a, int b) -&gt; a &gt; b ? a : b(a, b) -&gt; a &gt; b ? a : bList&lt;String&gt; list = new ArrayList();Collections.sort(list, new Comparator&lt;String&gt;() { public int compare(String s1, String s2) { retrun s2.compreTo(s1); } }Collections.sort(list, (s1,s2) -&gt; s2.compareTo(s1)); 함수형 인터페이스 메서드 참조(Method Reference) 스트림 API(Stream API) 기존의 컬렉션 프레임 워크를 활용하여 간결하게 코드를 작성할 수 있으며 병렬 처리, 스트림 파이프 라인 등을 통해 하나의 문장으로 다양한 데이터 처리 기능을 구현할 수 있다. 인터페이스의 개선 인터페이스에서는 메서드를 추가할 수 없었으나 default 추가 메서드를 활용 가능해졌다. static Optional null 값을 확인하고 관리할 수 있는 새로운 기능을 제공 java.time 패키지 LocalDate CompletableFuture 기능 Permanent Heap 의 제거 Java 7 12345678&lt;----- Java Heap -----&gt; &lt;--- Native Memory ---&gt;+------+----+----+-----+-----------+--------+--------------+| Eden | S0 | S1 | Old | Permanent | C Heap | Thread Stack |+------+----+----+-----+-----------+--------+--------------+ &lt;---------&gt; Permanent HeapS0: Survivor 0S1: Survivor 1 Java 8 1234&lt;----- Java Heap -----&gt; &lt;--------- Native Memory ---------&gt;+------+----+----+-----+-----------+--------+--------------+| Eden | S0 | S1 | Old | Metaspace | C Heap | Thread Stack |+------+----+----+-----+-----------+--------+--------------+ 참고Pratical 모던 자바https://johngrib.github.io/wiki/java-enhancements/","link":"/2020/10/14/java/2020-10-14-java-feature/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}