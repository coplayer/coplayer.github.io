{"pages":[{"title":"About Me","text":"","link":"/about/index.html"}],"posts":[{"title":"Vue Basic","text":"1234567891011121314151617181920212223242526272829303132{{}} 템플릿 표현식 - Mustache Expressionv-text {{}} 인코딩, 디코딩이 이루어 지기 때문에 html 태그가 그대로 노출됨v-html {{}} innerHTML 속성 태그 문자열을 파싱하여 나타냄 (예를 들어 개행을 하고 싶다면 &lt;/br&gt; 을 넣으면 개행이 적용됨)v-bind 생략하여 사용하면 :로 표현 가능하다.v-model : 양방향 바인딩이 지원된다.이벤트를 받을때마다 데이터 동기화&lt;input type=&quot;text&quot; v-model.lazy=&quot;name&quot;/&gt;//number : 숫자가 입력되면 number타입으로 자동으로 형변환//trim : 문자열 앞뒤 공백자동으로 제거v-if : 조건에 따른 렌더링 v-show : 조건에 따른 디스플레이여부 (랜더링됨. dispaly:none)v-for : 반복적인 렌더링v-for 와 v-if 순서는 for가 먼저 수행됨배열 데이터에 대해 값을 세팅할때는 Vue.set(리스트명, 인덱스,{})로 변경v-pre 안에 템플릿을 html로 컴파일하지 않음v-once 데이터를 변경하더라도 다시 렌더링을 수행하지 않음v-cloak 컴파일되지 않은 템플릿은 나타지 않도록 설정","link":"/2020/06/16/development/2018-04-29-vue/"},{"title":"HTML","text":"HyperText Markup Language HTML은 제목, 단락, 목록 등과 같은 본문을 위한 구조적 의미를 나타내는 것뿐만 아니라 링크, 인용과 그 밖의 항목으로 구조적 문서를 만들 수 있는 방법을 제공한다. 그리고 이미지와 객체를 내장하고 대화형 양식을 생성하는 데 사용될 수 있다. HTML은 웹 페이지 콘텐츠 안의 꺾쇠 괄호에 둘러싸인 “태그”로 되어있는 HTML 요소 형태로 작성한다. (WIKI 참조) htm You Only Need 10 HTML Tags 라는 페이지가 있다.12345678910&lt;h1&gt; - &lt;h6&gt; Heading&lt;p&gt; Paragraph&lt;i&gt; Italic&lt;b&gt; Bold&lt;a&gt; Anchor&lt;ul&gt; &amp; &lt;li&gt; Unordered List &amp; List Item&lt;blockquote&gt; Blockquote&lt;hr&gt; Horizontal Rule&lt;img&gt; Image&lt;div&gt; Division 샘플 페이지에 들어가면 이 태그만으로도 충분히 웹의 기본적인 레이아웃을 구성할 수 있음을 보여준다.","link":"/2020/06/16/development/2018-05-29-HTML/"},{"title":"Git & Github 사용법 정리","text":"GIT Document - https://git-scm.com/doc영어 / 한국어 모두를 지원한다. git init 초기화 (해당 폴더에 .git 폴더가 생성된다.) git remote add origin remoteURL 원격서버와 연결ex) git remote add origin https://github.com/coplayer/ git add [fileName] 추가 (staging area)ex) git add * (해당 폴더의 모든 파일을 추가) git commit -m [Message]ex) git commit -m first 확정 (local save) git push origin [branch] remote storege pushex) git push origin master git pull git의 remote를 가져와 자동으로 merge 해준다. git fetch remote storege 를 모두 가져온다. git merge fetch를 수행한 데이터를 merge한다. git branch [branch] 브랜치를 생성한다. git branch 브랜치 목록을 확인한다. git checkout 브랜치로 전환한다. git checkout-b [branch] 브랜치를 만들면서 Checkout까지 한 번에 하려면 git checkout 명령에 -b라는 옵션을 준다. git branch -D [branch] 브랜치를 삭제한다. git reset git head 버전 되돌리기","link":"/2020/06/16/development/2018-05-29-Git/"},{"title":"JSON 이란","text":"JSON ? JSON(제이슨, JavaScript Object Notation)은 속성-값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷이다. (wiki 참조)프로그래밍 언어와 플랫폼에 독립적이므로, 서로 다른 시스템간에 객체를 교환하기에 좋다. 숫자 : C나 자바에서의 8진수와 16진수를 표현하는 방법은 지원되지 않는다. 문자열(String) : “”로 묶어서 사용 배열(Array) : [] 로 묶어서 {} 선언하여 사용 객체(Object) : {} 묶어서 사용({“name2”: 50, “name3”: “값3”, “name1”: true}) link Page (http://www.json.org/) - 각 언어별 JSON 사용법 Json {“@nil” : “true”} t.industry instanceof Object // result is: truet.industry instanceof Array // result is: false Java string to Json자바 스트링 객체를 JSON으로 변환하여 사용해야 할때 다음과 같은 방법을 이용할 수 있습니다. 123456JSONParser jsonParser = new JSONParser();Object obj = jsonParser.parse(apiResult);JSONObject result = (JSONObject) obj;String code = (String)result.get(&quot;code&quot;);String msg = (String)result.get(&quot;msg&quot;); vo to Stringapache commons-lang 라이브러의 ToStringBuilder.reflectionToString 를 활용하여 vo 객체내에 모든 요소를 key와 value 형태로 출력합니다. 소스코드는 다음과 같다. public String toStringJson() { return ToStringBuilder.reflectionToString(this, ToStringStyle.JSON_STYLE); }","link":"/2020/06/16/development/2018-05-29-Json/"},{"title":"MarkDown 마크다운 문법","text":"1. 크기 조절# 글자크기 그리고 밑줄 (상단 제목과 동일) ## 글자크기 ### 글자크기 #### 글자크기 글자크기글자크기글자크기 2. 모양**굵게** _기울이기_ ~~취소선~~ 굵게 기울이기 취소선 3. 인용문&gt; 인용문 &gt;&gt; 인용문 &gt;&gt;&gt; 인용문 인용문 인용문 인용문 4. 글머리 기호 목록* 글머리 * 글머리 * 글머리 글머리 글머리 글머리 5. 링크테그 https://google.com 인사이드 링크 [Google](https://google.com) https://google.com 인사이드 링크 Google 6. 이미지 삽입![Alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Markdown-mark.svg/220px-Markdown-mark.svg.png) ![Alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Markdown-mark.svg/220px-Markdown-mark.svg.png &quot;Optional title&quot;) 7. 코드 삽입123``````javascript 12&lt;html&gt;&lt;/html&gt; 123function test(){ }","link":"/2020/06/16/development/2018-05-29-Markdown/"},{"title":"JUnit","text":"Unit Testing Framework Java 언어의 테스트를 위해서 사용함 (CUnit,PyUnit 등 언어별 지원) TDD (Test-Driven Development) 방법론에 활용되는 대표적인 Framework Github - https://github.com/junit-team Junit4 로 작성 (작성일 기준 Juint5 가 최신 2018.04.30) AnnotationJunit4 Doc - https://junit.org/junit4/javadoc/latest/index.html @Test //테스트 메소드 @Before //테스트 전 호출 @After //테스트 후 호출 @BeforeClass //테스트 전 1회만 @AfterClass //테스트 후 1회만 @Ignore //테스트에서 무시 assert Method Junit doc - http://junit.sourceforge.net/javadoc/org/junit/Assert.htmlassertArrayEquals(a,b) 배열 a와b가 일치함을 확인한다. assertEquals(a,b) 객체 a와b의 값이 같은지 확인한다. assertSame(a,b) 객체 a와b가 같은 객체임을 확인한다. assertTrue(a) a가 참인지 확인한다. assertFalse(a) a가 거짓인지 확인한다. assertNotNull(a) a객체가 Null이 아님을 확인한다.","link":"/2020/06/16/development/2018-05-29-Junit/"},{"title":"Oracle 관련","text":"DDL(Data Definition Language) 컬럼 관련컬럼 추가 - ALTER TABLE 테이블 ADD(컬럼명 VARCHAR2(100));이름 변경 - ALTER TABLE 테이블 RENAME COLUMN 컬러명 TO 변경컬럼명;타입 변경 - ALTER TABLE 테이블 MODIFY(컬럼명 VARCHAR2(50)); SYNONYM오라클의 객체 (테이블 , 뷰 , 시퀀스 , 프로시져 등)에 대체 이름(Alias)를 의미함생성 - CREATE 대체할 이름 FOR 원래이름;확인 - SELECT * FROM ALL_SYNONYMS WHERE SYSNOYM_NAME = ‘SYNONYM 이름’;삭제 - DROP SYNONYM [SYNONYM 이름]; DML(Data manipulation language)1. RAISE_APPLICATION_ERROR오라클 저장함수 RAISE_APPLICATION_ERROR를 사용하여 오류코드 -20000부터 -20999의 범위 내에서 사용자 정의 예외를 만들수 있다. STEP 1 : 예외의 이름을 선언 (선언절) STEP 2 : RAISE문을 사용하여 직접적으로 예외를 발생시킨다(실행절) STEP 3 : 예외가 발생할 경우 해당 예외를 참조한다(예외절) USER_DEFINED_EXCEPTION EXCEPTION; -- STEP1 --특정 조건에서 에러를 발생시킴 RAISE USER_DEFINE_ERROR; -- STEP 2 RAISE_APPLICATION_ERROR (-20001 ~ -20999 중에 정의 ,메세지를 정의); --SETP 3 2. 날짜관련1) TO_CHAR : 숫자나 날짜를 문자로 변환해 주는 함수가 바로 TO_CHAR로, 매개변수로는 숫자나 날짜가 올 수 있고 반환 결과를 특정 형식에 맞게 출력할 수 있다. SELECT TO_CHAR(SYSDATE, &apos;YYYYMMDD&apos;) FROM DUAL --YYYYMMDD 형식 SELECT TO_CHAR(123456789, &apos;999,999,999&apos;) FROM DUAL -- 숫자 3자리 마다 컴마 SELECT TO_CHAR(123456789, &apos;999.999.999&apos;) FROM DUAL -- 숫자 3자리 마다 점 SELECT TO_CHAR(123, &apos;RN&apos;) FROM DUAL --숫자 로마숫자로 변환 2) TO_DATE : 문자를 날짜형으로 변환하는 함수 SELECT TO_DATE(&apos;20180424&apos; ,&apos;YYYYMMDD&apos;) FROM DUAL; -- 문자를 date 형으로 변환 SELECT TO_DATE(&apos;20180424&apos; ,&apos;YYYY-MM-DD&apos;) FROM DUAL 3) 날짜 연산 SELECT SYSDATE + 1 FROM DUAL -- 현재 날짜 기준으로 1일 더하기 SELECT ADD_MONTHS(SYSDATE, 1) FROM DUAL -- 현자 날짜 기준으로 1달 더하기 --INTERVAL 숫자 기반 확인이 필요함 SELECT SYSDATE + (INTERVAL &apos;1&apos; YEAR) FROM DUAL --1년 더하기","link":"/2020/06/16/development/2018-05-29-Oracle/"},{"title":"SVN","text":"형상관리형상관리는 소스의 변화를 끊임없이 관리하는 것을 말한다. 단순히 소스 뿐만 아니라,이미지나 바이너리나 심지어 OS까지 버전관리를 한다. 가장 큰 장점은 소스관리를 통해서 프로젝트의 일관성, 안정성을 유지 할수 있다는 것이다. - Apache Subversion (SVN) CVS의 단점을 개선하고 거의 동일한 사용방법의 SVN ( WIKI 참조 ) VisualSVN - Window에서 SVN 서버환경을 구축하는 대표적인 프로그램. Manager를 이용하여 사용이 쉽다. ( VisualSVN Server 다운 ) tortoiseSvn - 클라이언트에서 SVN을 사용하는 대표적인 프로그램 ( tortoiseSVN 다운 ) - SVN 이관windows 환경에서 SVN 서버에서 이관 작업을 수행하게 되었다. Repository 폴더를 통째로 복사 해당 서버의 Repository에 복사 SVN server 설치 복사한 경로로 Repository 지정 심플하게 완료 되었다.명령어를 통하여 SVN dump를 만드는 방법이 존재하는 것으로 보인다.(링크 참조 Link) 이관된 SVN 에 sync이클립스 사용시 적용 -SVN Repository 에 생성되어 있는 Repository마우스 우 클릭 Location Properties 의 URL로 변경relocate 가 수행됨","link":"/2020/06/16/development/2018-05-29-SVN/"},{"title":"Secure Coding","text":"1. Cookie 조작 취약점가. 취약점 상세 내용 및 보안 대책Cookie는 HTTP 프로토콜의 비연결성 특징을 고려하여 사용자 Session 관리의 편의성을 도모하기 위해 사용되는 기술적 방법이며, 주로 웹사이트의 설정값을 저장하여 각 사용자가 웹사이트에 접속할 때 동일한 설정을 유지하거나 또는 사용자의 인증과 관련된 정보를 처리하기 위해 사용된다.그러나 Cookie 근본적으로 Client Side Session 기술로서 전달되는 값에 대한 사용자의 조작이 가능한 문제가 있기 때문에 Cookie 의 변수에 중요한 정보를 포함하여 사용하는 경우 Client 측 웹브라우저의 조작을 통해서 해당 값을 변조하여 인증을 우회하거나 타 사용자의 정보를 도용하는 등의 취약점이 발생할 수 있다.또한 Cookie 로 전달되는 변수는 GET / POST 를 통해서 전달되는 변수와 동일하게 SQL Injection 및 파라미터 조작 등의 공격에 영향을 받을 수 있다. 나. 보안 대책(1) Session 방식의 사용평문 정보를 Cookie 변수에 저장하여 서버와 클라이언트 간에 전달하는 일반적인 방식의 Cookie 활용은 더 이상 권장되지 않는다.WAS와 같은 서버측 스크립트 엔진은 Cookie 보다 발전된 형태인 Session 방식의 상태값 전달 방식을 지원한다. Session 방식은 서버측의 저장 공간에 각 사용자별로 인증 정보나 설정값 등 특화된 정보를 저장할 수 있는 저장소를 지원하며 암호화된 Cookie 변수를 통해 이를 식별하게 하는 방식으로 이루어져 있으므로 Client 측에서 정보의 변조가 불가능하며, 따라서 Cookie 방식보다 안전하다.따라서 인증이나 권한 정보와 같이 변조되어서는 안되는 중요한 정보는 가능한 Session 방식을 이용하여 구현하는 것이 바람직하다. (2) Cookie 변수의 암호화 및 입력값 검증만일 Cookie 변수에 데이터를 저장하여 전송할 필요가 있는 경우, 해당 정보가 인증 및 권한 등 중요한 정보일 경우 평문으로 사용해서는 안되며 반드시 SEED, 3DES, AES등 공인된 암호화 알고리즘을 사용하여 정보를 암호화한 후 사용해야 한다.또한, 중요한 정보가 아니라고 해도, Cookie 변수를 통해서 전달되는 변수값은 GET/POST 파라미터 변수와 마찬가지로 SQL Injection, XSS, 파라미터 조작 등과 같은 공격에 영향을 받기 때문에 각각의 취약점을 방어하기 위한 적절한 입력값 검증이 수행되어야 한다. Cookie 변수로 전달된 값이 DB와 연동하는 로직으로 전달되어 사용되는 경우 반드시 SQL Injection 공격을 차단하기 위한 대응책을 적용해야 함Cookie 로 전달되는 변수가 장바구니, 결재 모듈 등 웹사이트의 중요한 로직에서 사용되는 경우, 변수의 변조 가능성에 대비한 적절한 유효성 검증이 수행되어야 함 출처-http://wikisecurity.net/guide:jsp_%EA%B0%9C%EB%B0%9C_%EB%B3%B4%EC%95%88_%EA%B0%80%EC%9D%B4%EB%93%9C","link":"/2020/06/16/development/2018-05-29-SecureCoding/"},{"title":"Oracle 명령어 및 TIP ","text":"티스토리에 포스팅을 다시 가지고 왔습니다. - Oracle 컬럼 속성 추가 삭제Oracle DB 사용할 때 이상하게도 매번 찾아보게 되는 컬럼 추가 삭제 12345alter table 테이블명 add(컬럼 속성명());alter table 테이블명 rename column 컬럼명 to 변경컬럼명;alter table 테이블명 modify(컬럼명 속성명());- xml 특수문자 이스케이프xml 작성시에 종종 오류를 발생하게 하는 특수문자 변환 코드 123456&amp; : &amp;&lt; : &lt;&gt; : &gt;‘ : &amp;apos;” : &quot;엔터 : &amp;#10; - ORACLE ORA-01861: literal does not match format string12345ORACLE DATE 컬럼을 문자로 조회시 자주 발생하는 에러조건절에 좌변의 DATE 객채를 TO_CAHR 포맷으로 CAST 예) TO_CHAR(컬럼, &apos;YYYYMMDD&apos;) - 채번하기 자릿수 LPAD, SEQUENCE 수동으로 채번 할때 많이 사용한다. LPAD 자릿수SELECT LPAD(컬럼, 자릿수, 채울문자나 숫자) FROM DUAL; 컬럼을 MAX 채번 하기 12345678910111213141516171819202122232425262728SELECT NVL(MAX(컬럼) ,1) FROM TABLE WHERE PK = PK SEQUENCE 시퀀스 생성CREATE SEQUENCE &quot;시퀀스명&quot; 구조 확인DESC USER_SEQUENCES시퀀스 값 사용&quot;시퀀스&quot;.NEXTVAL =&gt; 현재 시퀀스의 다음 증가값 반환&quot;시퀀스&quot;.CURRVAL =&gt; 현재 시퀀스 값 반환ㆍSTART WITH : 시작값 지정ㆍINCREMENT BY : 연속적인 증가치 지정ㆍMAXVALUE: 가질 수 있는 최대값 지정ㆍMINVALUE : 가질 수 있는 최소값 지정ㆍCYCLE: 지정된 최대값까지 증가되면 START WITH 로 지정한 시작값에서 다시 시작 ※ NOCYCLE : 최대값까지 증가가 완료되면 에러 발생ㆍCACHE : 메모리상의 시퀀스값 관리, 기본값은 20 시퀀스 삭제DROP SEQUENCE &quot;시퀀스&quot;시퀀스 수정ALTER SEQUENCE &quot;시퀀스&quot; &quot;변경할 속성&quot; &quot;숫자&quot;※ 시작숫자(START WITH)는 변경할 수 없음, 시퀀스를 새로 생성해야만 함","link":"/2020/06/16/development/2018-06-01-oracleTip/"},{"title":"Visual Code 내가 필요한 단축키 정리","text":"IDE는 이클립스를 주로 사용해왔다.익숙한 도구는 편하지만 새로운 도구는 언제든 흥미를 주기에 충분하다. 이클립스는 자바 개발에는 무엇보다 충실하다.다만 요즘 하이브리드 앱을 개발하게 되면서 자바스크립트 개발에 적합한 에디터가 필요하다고 생각해서 여러 IDE 중에 무료로 사용할 수 있는 것 들 중 Visual Code를 선택 했다. 사용하면서 장점은 여러가지 있겠지만 가볍다. 다른 기능적인 단축키는 많지만 코드를 작성하기 위한 편집용 단축키를 주로 정리하도록 하겠다.하지만 모든 키는 설정이 가능하다는 설정이 바꿀 수 있다. (메뉴에서 파일 &gt; 기본 설정 &gt; 바로가기 키 ) 기본적으로 사용하는 키가 편한지 익혀보고 본인에 맞는 것을 사용하도록 하자. 1. 열편집 : SHIFT + ALT + 드래그 2. 열복사 : SHIFT + ALT + 하방향키 3. 대/소문자 : SHIFT + ALT + Q , ALT + Q 4. 한줄 삭제 : CTRL + SHIFT + K 5. 콘솔 열기 : CTRL + ` 6. 코드 정렬 : 코드 블럭 지정 + CTRL + K,F 7. 코드 줄바꿈 : ALT + 상하방향키","link":"/2020/06/16/development/2018-05-29-VisualCode/"},{"title":"jQuery 관련","text":"javascript library로 javascript의 생산성을 향상 시켜주는 라이브러리. jQuery 대부분의 튜토리얼을 제공[ W3SCHOOL JQUERY ] jQuery CDN12&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; jQuery DOM 에 selector123456789101112131415$(document).ready(function(){ // jQuery methods go here...});$(this).hide() - hides the current element.//현재 페이지 모두에 적용$(&quot;p&quot;).hide() - hides all &lt;p&gt; elements. //p tag 모두에 접근$(&quot;.test&quot;).hide() - hides all elements with class=&quot;test&quot;. //test class명 접근$(&quot;#test&quot;).hide() - hides the element with id=&quot;test&quot;.//엘리멘트 id에 접근$(&quot;tr:even&quot;) Selects all even &lt;tr&gt; elements // 응용 jQuery Syntax For Event Methods123456789101112131415161718192021222324252627282930313233343536373839404142$(&quot;p&quot;).click(function(){ $(this).hide();});$(&quot;p&quot;).dblclick(function(){ $(this).hide();});$(&quot;#p1&quot;).mouseleave(function(){ alert(&quot;Bye! You now leave p1!&quot;);});$(&quot;#p1&quot;).mouseup(function(){ alert(&quot;Mouse up over p1!&quot;);});$(&quot;#p1&quot;).hover(function(){ alert(&quot;You entered p1!&quot;);},function(){ alert(&quot;Bye! You now leave p1!&quot;);});$(&quot;input&quot;).blur(function(){ $(this).css(&quot;background-color&quot;, &quot;#ffffff&quot;);});$(&quot;p&quot;).on(&quot;click&quot;, function(){ $(this).hide();});$(&quot;p&quot;).on({ mouseenter: function(){ $(this).css(&quot;background-color&quot;, &quot;lightgray&quot;); }, mouseleave: function(){ $(this).css(&quot;background-color&quot;, &quot;lightblue&quot;); }, click: function(){ $(this).css(&quot;background-color&quot;, &quot;yellow&quot;); } }); $ 함수 이용. jQuery 오브젝트의 팩토리 메소드이다. 각각의 함수들은 jQuery 오브젝트를 반환하고 서로 연계할 수 있다. $. -가 앞에 붙은 함수 이용. 이들 함수는 jQuery 오브젝트 그 자체와 연동되지는 않는다.","link":"/2020/06/16/development/2018-05-29-jQuery/"},{"title":"SpringAnnotation","text":"스프링 MVC에서 자주 사용되는 Annotation을 간략하게 정리한다. @Component - 클래스에 선언되는 Annotation. Spring component-scanning 에 의해 선언된 클래스는 컨텍스트에 빈으로 등록된다. @Autowired - @Controller - MVC패턴의 Controller로 선언한다. @Component로 선언 할 수 있지만 @RequestMapping(value={“/uri”})@ResponseBody 등을 활용할 수 있다. @RestController - @ResponseBody를 선언하지 않는다. RestController(Spring 4.0.1부터 제공) @RequestMapping @Repository @Service @Required @Qualifier @Resource @Scope @PostConstruct - Spring LifeCycle에서 InitializingBean인터페이스의 afterPropertiesSet 역할을 할수 있도록 메소드 상단에 선언하다.(Bean 초기화할 때 수행) @PreDestroy - Spring LifeCycle에서 DisposableBean 인터페이스의 destroy 역할을 할수 있도록 메소드 상단에 선언한다.(Bean 소멸될 때 수행) @Inject @RequestParam @SessionAttributes @RequestBody @ResponseBody @PathVariablegit @Aspect - AOP 클래스 선언 @Pointcut(“whthin(범위)”)","link":"/2020/06/16/development/2018-06-05-springAnnotation/"},{"title":"Spring DI","text":"프로젝트에서 꾸준히 사용해 오던 FrameWork이다. 단순하게 CRUD를 구현하는 데 초점을 맞춰서 사용하였으나 제대로 된 이해를 하고 응용해 나가기 위해서는 정리가 필요하다는 생각이 절실한 요즘이다. 기본부터 다시 시작하자. Spring 의 DI스프링의 기본적인 구조 중에 DI(Dependency Injection)는 구성요소간의 의존 관계가 소스코드 내부가 아닌 외부의 설정을 통해 정의되게 하는 디자인 패턴 중의 하나이다. 유연 하도록 구현할 수 있다. Srping DI 장점Spring에서는 빈팩토리를 xml에 선언하여 이를 객체에 주입하여 결합도*를 낮추어 코드를 변경하거나 설계변경에 유연하게 대처할수 있으며 협업에 있어서 이를 통하여 객체를 일관성 있게 사용하고 유지보수의 편의를 제공한다.DI는 OOP의 개념과 유사하며 DI를 통하여 주입된 객체만을 변경하여 주입받은 객체를 변경할 수 있다. 소프트웨어 공학에서, 결합도(coupling) 또는 의존도는 어떤 모듈이 다른 모듈에 의존하는 정도를 나타내는 것이다. 스프링 컨테이너 생명주기 (Lifecycle)Spring 컨테이너의 lifecycle을 이용하여 생성시 소멸시 실행되는 메소드를 구현할 수 있다. 123456789101112 // 생성GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(); // 설정 ctx.load(&quot;classpath:applicationCTX.xml&quot;); ctx.refresh(); //--&gt;InitilizingBean afterProrpertiesSet 메소드 호출 // 사용 Student student = ctx.getBean(&quot;student&quot;, Student.class); System.out.println(&quot;이름 : &quot; + student.getName()); System.out.println(&quot;나이 : &quot; + student.getAge()); // 종료 ctx.close();//--&gt; DisposableBean destroy 메소드 호출 인터페이스 구현 코드12345678910111213 public class student implements InitializingBean, DisposableBean{ @Overridepublic void afterPropertiesSet() throws Exception { // TODO Auto-generated method stub System.out.println(&quot;afterPropertiesSet()&quot;);}@Overridepublic void destroy() throws Exception { // TODO Auto-generated method stub System.out.println(&quot;destroy()&quot;);} Annotation 구현123456789 @PostConstructpublic void initMethod() { System.out.println(&quot;initMethod()&quot;);}@PreDestroypublic void destroyMethod() { System.out.println(&quot;destroyMethod()&quot;);} AOP(Aspect Oriented Programing) Java에서는 다중 상속이 불가하다. 다양한 모듈에 공통기능을 부여하는 한계가 있다. AOP는 공통 기능을 분리하여 모듈에 적용하는 기능이다. AOP 용어 Aspect : 공통기능 Advice : Aspect의 기능 자체 joinpoint : Advice를 적용하는 부분 Pointcut : joinpoint의 부분으로 실제 advice가 적용된 부분 Weaving : Advice를 핵심 그닝에 적용하는 행위 AOP의 적용 pom.xml 설정 123456&lt;!-- AOP --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.2&lt;/version&gt;&lt;!-- 버전 적용확인이 필요함 --&gt;&lt;/dependency&gt; 공통 기능의 클래스 생성 - Advice 역할 클랙스123456789101112131415161718192021import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;public class LogAop { public Object loggerAop(ProceedingJoinPoint joinpoint) throws Throwable { String signatureStr = joinpoint.getS1 String signatureStr = joinpoint.getSignature().toShortString(); //메소드의 네임 System.out.println( signatureStr + &quot; is start.&quot;); long st = System.currentTimeMillis(); try { Object obj = joinpoint.proceed();//메소드 수행 return obj; } finally { long et = System.currentTimeMillis(); System.out.println( signatureStr + &quot; is finished.&quot;); System.out.println( signatureStr + &quot; 경과시간 : &quot; + (et - st)); } }} xml 설정 파일에 Aspect 설정 - 네임스페이스에서 aop 설정을 추가함 12345678910111213141516&lt;bean id=&quot;logAop&quot; class=&quot;com.javalec.ex.LogAop&quot; /&gt;&lt;aop:config&gt; &lt;aop:aspect id=&quot;logger&quot; ref=&quot;logAop&quot;&gt; &lt;aop:pointcut id=&quot;publicM&quot; expression=&quot;within(com.javalec.ex.*)&quot; /&gt;&lt;!--이름과 적용범위 지정--&gt; &lt;aop:around pointcut-ref=&quot;publicM&quot; method=&quot;loggerAop&quot; /&gt;&lt;!--AOP의 기능 지정--&gt; &lt;!-- &lt;aop:before : 메소드 실행전 &lt;aop:after-returning : 메소드 정상 실행 후 &lt;aop:after-throwing : 메소드 실행 중 exception 발생시 &lt;aop:after : 메소드 실행중 exception이 발생하여도 실행 &lt;aop:around : 메소드 실행 전/후 및 exception이 발생하여도 실행 --&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; AOP를 @Aspect 어노테이션에 의해서 구현할 수 있다. 소스 xml 설정에서 느끼는 복잡도는 더 낮은 듯하나 개인적으로 실무에서는 셋업을 직접 해보는 기회가 많지 않아 여러 소스를 참고해봐야겠다. pom.xml 설정123456&lt;!-- AOP --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.2&lt;/version&gt;&lt;!-- 버전 적용확인이 필요함 --&gt;&lt;/dependency&gt; @Aspect 가 구현된 class 파일 생성12345678910111213141516171819202122232425262728293031323334353637import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;@Aspect//AOP 클래스 지정public class LogAop { @Pointcut(&quot;within(com.javalec.ex.*)&quot;)//범위 지정 private void pointcutMethod() { } @Around(&quot;pointcutMethod()&quot;)//pointcut 동작 지정 public Object loggerAop(ProceedingJoinPoint joinpoint) throws Throwable { String signatureStr = joinpoint.getSignature().toShortString(); System.out.println( signatureStr + &quot; is start.&quot;); long st = System.currentTimeMillis(); try { Object obj = joinpoint.proceed(); return obj; } finally { long et = System.currentTimeMillis(); System.out.println( signatureStr + &quot; is finished.&quot;); System.out.println( signatureStr + &quot; 경과시간 : &quot; + (et - st)); } } @Before(&quot;within(com.javalec.ex.*)&quot;)//기능이 시작하기전에 실행되는 advice public void beforAdvice() { System.out.println(&quot;beforAdvice()&quot;); } } 3. XML파일 &lt;aop:aspect-autoproxy&gt; 설정12&lt;aop:aspectj-autoproxy /&gt;&lt;bean id=&quot;logAop&quot; class=&quot;com.javalec.ex.LogAop&quot; /&gt;&lt;!-- AOP 클래스 지정--&gt;pointcut 표현식1234567891011// @Pointcut(&quot;execution(public void get*(..))&quot;) // public void인 모든 get메소드// @Pointcut(&quot;execution(* com.javalec.ex.*.*())&quot;) // com.javalec.ex 패키지에 파라미터가 없는 모든 메소드// @Pointcut(&quot;execution(* com.javalec.ex..*.*())&quot;) // com.javalec.ex 패키지 &amp; com.javalec.ex 하위 패키지에 파라미터가 없는 모든 메소드// @Pointcut(&quot;execution(* com.javalec.ex.Worker.*())&quot;) // com.javalec.ex.Worker 안의 모든 메소드// @Pointcut(&quot;within(com.javalec.ex.*)&quot;) //com.javalec.ex 패키지 안에 있는 모든 메소드// @Pointcut(&quot;within(com.javalec.ex..*)&quot;) //com.javalec.ex 패키지 및 하위 패키지 안에 있는 모든 메소드// @Pointcut(&quot;within(com.javalec.ex.Worker)&quot;) //com.javalec.ex.Worker 모든 메소드 // @Pointcut(&quot;bean(student)&quot;) //student 빈에만 적용// @Pointcut(&quot;bean(*ker)&quot;) //~ker로 끝나는 빈에만 적용","link":"/2020/06/16/development/2018-06-11-SpringStudy/"},{"title":"Iterator Pattern","text":"Design Pattern 중에 하나인 Iterator Pattern은 객체 지향형 언어에서 Collection의 자료형(LinkedList, HashMap, Vetor 등등)과 상관없이 탐색할 수 있도록 해주는 인터페이스를 이용하는 패턴이다. 객체지향을 언어를 제대로 사용하자. 자바에서 Iterator는 java.util.Collection 인터페이스의 iterator 를 사용한다.인터페이스의 메소드는 다음과 같다. 123456789public interface Iterator {boolean hasNext(); //Returns true if the iteration has more elements.Object next(); // Returns the next element in the iteration.void remove(); //Removes from the underlying collection the last element returned by this iterator (optional operation).}각 Collection에 Iterator를 가져오는 것으로 사용한다.Iterrator의 예제는 다음과 같다. 1234567891011121314151617//LinkedListList&lt;string&gt; list = new LinkedList&lt;string&gt;();Iterator&lt;string&gt; itr = list.iterator();while(itr.hasNext()) { System.out.println(itr.next());}//HashMapHashMap&lt;integer, String&gt; map = new HashMap&lt;integer, String&gt;();Iterator&lt;string&gt; itr = map.values().iterator();while(itr.hasNext()) { System.out.println(itr.next());}위 코드와 같이 Collection의 자료형은 서로 다지만 출력에 쓰이는 출력 방법은 동일하다.어떤 자료형이든 적용하여 패턴 자체에 익숙해지면 자료형을 리펙토링 할때도 유용하게 쓰인다. 번외로 코딩 테스트를 진행하는 회사들에서 종종 이패턴을 이용해서 코딩을 하는 거나 기존 코드를 수정할때 패턴을 구현하라고 하는 경우가 종종 있으니 참고 하기 바란다. 참고 JAVA DOC","link":"/2020/06/16/development/2018-06-07-iterator/"},{"title":"MAC TIP ","text":"mysql workbench 단축키 현재 커서가 위치하는 쿼리 실행 : Ctrl + Enter 쿼리 보기좋게 정렬하기(Beautify Query) : Ctrl + B 세미클론(;)으로 분리된 쿼리 다중(여러개) 실행 : Ctrl + Shift + Enter 새로운 쿼리 에디터 열기 : Ctrl + T (Ctrl키 + t) 저장된 스크립트파일(*.sql)파일 열기 : Ctrl + Shift + O (Ctrl키 + Shift키 + o) 쿼리를 보기 좋게 정렬 : Ctrl + B (Ctrl키 + b) Reverse Engineer Database : Ctrl + R (Ctrl키 + r) mac OS 단축키 숨긴파일 확인 shift + command + . 켜져있는 프로그램 한눈에 보기 control + 방향키(위로) 프로그램 종요 : command + w 프로그램 숨기기 : command + h mac에서 tomcat service 가 살아 있을때process 를 종료한다.$ sudo lsof -i :8080$ 패스워드 입력$ kill -9 위에서찾는PID값을넣는다","link":"/2020/06/16/development/2018-07-03-mac/"},{"title":"jQuery 를 이용한 체크박스 전체 선택 및 해제","text":"HTML checkbox 들의 전체선택 및 해제를 jquey를 활용하여 구현. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function(){ //전체선택 체크박스 클릭 $(&quot;#check_all&quot;).click(function(){ //전체선택 체크박스가 체크된상태일경우 if($(&quot;#check_all&quot;).prop(&quot;checked&quot;)) { //input type 이 checkbox인 경우 전부 선택 $(&quot;input[type=checkbox]&quot;).prop(&quot;checked&quot;,true); } else { //input type 이 checkbox인 경우 전부 해제 $(&quot;input[type=checkbox]&quot;).prop(&quot;checked&quot;,false); } }) })&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; 전체선택 : &lt;input type=&quot;checkbox&quot; id=&quot;check_all&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2020/06/16/development/2018-07-16-JavascriptCheckAll/"},{"title":"Spring MVC 에서 LOGBack 설정 그리고 log4jdbc 설정","text":"단순히 logback에서 SQL에 파라미터를 세팅하고 SQL를 정렬해서 log를 효율적으로 관리 할수 없을까로 시작 하였는 데 결국에는 로그백 문서 까지 확인하게 되었습니다. Reasons to prefer logback over log4j 로그백의 장점은 해당 사이트에서 확인할 수 있습니다.설정은 Maven 에서 진행하여 Maven 바탕으로 포스팅합니다. pom.xml 에 dependency 추가 12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt;&lt;/dependency&gt; resouce 폴더에 logback.xml 설정12345678910111213141516171819202122&lt;!-- Console Log Setting --&gt;&lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;withJansi&gt;true&lt;/withJansi&gt; &lt;!-- 로그에서 제외를 위한 필터 message 를 활용 --&gt; &lt;filter class=&quot;ch.qos.logback.core.filter.EvaluatorFilter&quot;&gt; &lt;evaluator&gt; &lt;expression&gt;return message.contains(&quot;로그에서 제외할 키워드를 입력&quot;);&lt;/expression&gt; &lt;/evaluator&gt; &lt;OnMismatch&gt;NEUTRAL&lt;/OnMismatch&gt; &lt;OnMatch&gt;DENY&lt;/OnMatch&gt; &lt;/filter&gt; &lt;!-- 패턴은 자유롭게 사용 실무에 적용한 것을 공유함 --&gt; &lt;encoder&gt; &lt;pattern&gt;[%d{yyyy/MM/dd HH:mm:ss}] %highlight([%-5level])| %cyan(%-25.25logger{0}) | %highlight(%msg%n)&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt;&lt;!--로그 레벨을 확인하여 출력--&gt;&lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;&lt;/root&gt; 필터를 포함한 간단한 설정입니다. 활용 방법은 다양합니다. 다만 이렇게 설정해서 사용할경우 sql이 select * from where a = ? and b = ? 와 같이 물음표로 파라미터는 따로 표현됩니다. 파리미터도 모두 치환해서 보여 줄수 있는 설정을 추가 진행 했습니다. pom.xml에 설정을 추가합니다. 1234567891011121314151617181920&lt;!-- https://mvnrepository.com/artifact/com.googlecode.log4jdbc/log4jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;com.googlecode.log4jdbc&lt;/groupId&gt; &lt;artifactId&gt;log4jdbc&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;``` spring 4 를 기준으로 applicaton-config.xml 에 jdbc 설정을 변경합니다.```xml&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;net.sf.log4jdbc.DriverSpy&quot; /&gt; ~~&lt;/bean&gt;&lt;!-- 변경하세요 기존은 jdbc:mysql:// --&gt;&lt;entry key=&quot;dev.db.url&quot;&gt;jdbc:log4jdbc:mysql://logback.xml 에 jdbc 관련 내용을 추가합니다. 123456789&lt;!--jdbc 관련 로그 컨트롤--&gt;&lt;logger name=&quot;jdbc&quot; level=&quot;OFF&quot;/&gt;&lt;logger name=&quot;jdbc.sqlonly&quot; level=&quot;DEBUG&quot;/&gt;&lt;logger name=&quot;jdbc.sqltiming&quot; level=&quot;OFF&quot;/&gt;&lt;logger name=&quot;jdbc.audit&quot; level=&quot;OFF&quot;/&gt;&lt;logger name=&quot;jdbc.resultset&quot; level=&quot;OFF&quot;/&gt;&lt;logger name=&quot;jdbc.resultsettable&quot; level=&quot;OFF&quot;/&gt;&lt;logger name=&quot;jdbc.connection&quot; level=&quot;OFF&quot;/&gt; 끝으로 로컬 개발환경에 톰켓 VM Option 에 다음을 추가해 줍니다.이 옵션이 적용되면 쿼리 문이 정렬되어 보여 집니다. 1-Dlog4jdbc.dump.sql.maxlinelength=0 추가사항 사용하다보니 log4jdbc.properties 설정을 찾는 메세지를 발견했습니다. resouce 폴더에 다음과 같이 log4jdbc.properties 파일을 추가합니다.1log4jdbc.spylogdelegator.name=net.sf.log4jdbc.log.slf4j.Slf4jSpyLogDelegator 이렇게 설정하여 저는 로그를 확인하고 있습니다. 다만 logback에 log4jdbc 설정을 하므로 성능에 어떠한 영향을 미치는 지까지는 확인해보지 못하였습니다. 포스팅을 보시고 성능에 문제가 되신다면 jdbc 설정을 제외하고 적용하시면 됩니다.","link":"/2020/06/16/development/2018-08-16-Logback/"},{"title":"javascript , Jquery Tip ","text":"javascript와 jQuery를 사용하다보면 종종 활용하게 되는 기능이나 method를 모아둔 포스팅 입니다. 1. javascript lastIndexOf 활용javascript 의 lastIndexOf() method를 활용하여 확장자를 추출하여 파일 타입을 구분하는 경우가 종종 있습니다. 다음과 같이 활용하여 사용할 수 있습니다. 123456789101112/** * lastIndexOf(&apos;.&apos;) * 뒤에서부터 &apos;.&apos;의 위치를 찾기위한 함수* 검색 문자의 위치를 반환한다.* 파일 이름에 &apos;.&apos;이 포함되는 경우가 있기 때문에 lastIndexOf() 사용*/var filename = item.orgin_file_nm;var length = filename.length;var lastDot = filename.lastIndexOf(&apos;.&apos;) + 1;// 확장자추출 lowercasevar fileExt = filename.substring(lastDot, length).toLowerCase(); 2. jQuery .css() 활용display 속성을 활용하여 element를 보이고 숨기는 기능 활용할 수 있습니다. 12345678910var num = 0;//보이기/숨기기function imageview(num) { if ($(&apos;#img_&apos; + num).css(&quot;display&quot;) != &quot;none&quot;) { $(&apos;#img_&apos; + num).hide(); } else { $(&apos;#img_&apos; + num).show() }}3. jQuery .find() 활용find() 를 활용하여 id값에 속해있는 img element를 추출하여 src를 맵핑하는 데 활용한 예제 입니다. 12345//첨부된 이미지의 src를 추출var list = $(&apos;#fileList&apos;).find(&apos;img&apos;);for (var i = 0; i &lt; list.length; i++) { console.log(list[i].src);}4. coding style 가이드javascript는 다른 언어에 비하여 코딩 스타일이 정말 다양한 편이고 다이나믹하게 구현이 가능하다보니 어떤 코딩 스타일이 표준이라고 보기 어렵습니다. 종종 코딩하다가도 이게 맞는건가? 라는 생각을 종종합니다. 그래서 찾아보니 구글에서는 코딩 스타일에 대한 가이드를 해주는 페이지가 있었습니다. 이 포스팅을 참조 하였습니다.","link":"/2020/06/16/development/2018-06-20-javascriptTIP/"},{"title":"lombok","text":"Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Project lombok 에 나와 있는 문장 중에 일부 이다. 그만큼 반복해서 선언 또는 코딩해야 하는 부분을 크게 축약하여 준다. Java의 Sring Framework에서 DTO(Data Transfer Ojbect), VO(Value Object), Entity 관련 클래스에서 중복으로 사용해야하는 코드를 Annotaion 선언으로 대신 하도록 해주는 플러그 인이다. Annotation@Getter/Setter - 선언된 변수를 getter, setter로 선언해 준다. @toString - toString 생성 @EqualsAndHashCode Equals,HashCode 생성 @NoArgsConstructor 파라미터가 없는 기본 생성자 @AllArgsConstructor 모든 필드 값을 파라미터로 받는 생성자 @RequiredArgsConstructor final이나 @NonNull인 필드 값만 파라미터로 받는 생성자 @Builder - BuilderPattern 적용 @Log - private static final logger 객체 생성 @Data - getter, setter, toString, hasCode, equals, requiredArgsConstructor 를 한번에 생성 좋은 플러그인인 만큼 실무에서는 보수적으로 사용하기를 요하는 글들이 보인다. 주의사항을 참고하자. 뭐 이정도면 거의 안쓰는 수준이지만 getter와 setter만이라도 심플해진다. 참고한 페이지 Projectlombok BuilderPattern http://tomining.tistory.com/180 http://wonwoo.ml/index.php/post/1607 http://www.daleseo.com/lombok-popular-annotations/","link":"/2020/06/16/development/2018-05-29-lombok/"},{"title":"CrossOrigin REST API 서버 분리하기","text":"CrossOriginfront와 rest api를 분리하여 사용하는 경우 crossdomain 문제가 발생하게 된다. header에 Access-Control-Allow-Origin 을 선언해 주어 서로 다른 서버의 간의 api통신을 가능하도록 하였다. http protocal 에 대한 이해가 심층 적으로 필요하다. 1234567891011121314151617181920import javax.servlet.*;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class SimpleCORSFilter implements Filter { public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) res; response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, PUT, DELETE&quot;); response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with, origin, content-type, accept&quot;); response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); chain.doFilter(req, response); } public void init(FilterConfig filterConfig) {} public void destroy() {}}","link":"/2020/06/16/development/2018-08-21-CrossOrigin/"},{"title":"SpringBoot","text":"Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.Spring 공식 사이트의 Spring boot에 대한 첫 소개이다. 말 그대로 쉽게 만들고 “just run” 하면 되는 어플리케이션 플랫폼이다. 다른 언어 진영에서의 웹 프레임웍인 node.js 의 express, python 의 django, ruby 의 rails 등은 빠르고 특이한 설정없이 웹을 생성하여 서비스 및 테스트를 실행수 있는 반면의 spring은 많은 기능이 있는 만큼 dependency 설정이나 기타 xml 설정(초기 빌드업), was나 서버 배포시 발생 문제를 해결하는 데 많은 시간을 할애 해야한다. 아마도 이런한 단점을 보완하는 점에서 java 진영의 spring boot는 사용할만한 이유는 충분하다고 본다. - Spring boot 장점 독립 실행 형 Spring 애플리케이션 작성(개발 진행할때 따로 tomcat설정 필요없음) Tomcat, Jetty 또는 Undertow를 직접 임베드 (WAR 파일을 배치 할 필요 없음) XML 생성을위한 코드 생성 및 요구 사항 없음 Dependency 의 표준화(maven, gradle)","link":"/2020/06/16/development/2018-06-05-spring/"},{"title":"VS Code TIP ","text":"GIT 관련 VS CODE의 플러그인 들을 설치할 때 자동으로 플러그인의 단축키를 적용해 주는 경우가 종종있다. 자신이 변경할 단축키와 중복되지 않는지 유의가 필요하다. 최근 vs code로 git을 사용하다가 계속해서 id 와 pw 을 물어봐서 왜 이러지? 하다가 해결책을 찾았다. https://github.com/git-for-windows/git/releases 위 사이트에 접속하여 Git 최신 버전을 설치하면 현상이 없어졌다.","link":"/2020/06/16/development/2018-08-30-vscodetip/"},{"title":"리눅스 명령어","text":"linux command 의 세부 옵션과 함께 활용하자. 1. pwd (Print Working Directory)현재 작업중인 디렉토리 위치 확인 2. cd디렉토리 이동12345678//최상위$ cd ~//상위$ cd ..//디렉토리 이동$ cd ~/usr/ 3. ls (List)1234567891011121314151617181920//디렉토리 내의 목록 조회ls //all 모두 출력(숨겨진 파일)ls -a //long 자세하게ls -l//두개의 옵션 사용ls -al//디렉토리 정보 조회ls -d //파일 형식을 파일 뒤에 붙여줌ls -F//하위 경로와 파일 모두 보여줌$ ls -R 4. rm (삭제)123456789101112//삭제$ rm home //디렉토리까지 삭제$ rm -r home/ //쓰기보호 등 권한과 상관없이 삭제$ rm -f home//같이 사용할 수 있다.$ rm -rf home 5. cp , mv복사, 이동 6. mkdir , rmdir디렉토리 생성 , 삭제 7. tail (파일 내용을 출력)12345678//마지막 100번째줄 까지 출력tail -n 숫자//바이트단위tail -c 숫자//실시간 출력tail -f8. nohup프로세스 중단(hangup)을 무시하고 명령어를 실행하는 명령어백그라운드에서 데몬을 실행 할때 종종 사용한다.표준출력을 nohup.out 에 저장한다. 1234nohup 파일명//파일을 실시간으로 확인할 수 있다.tail -f nohup.out","link":"/2020/06/16/development/2018-08-28-LinuxCommand/"},{"title":"Lombok Intellij install","text":"Lombok Intellij 에서 사용하기Intellij IDE &gt; Preferences &gt; plug-inlombok 검색 &gt; 설치 설치 이후에 intellij 에서 다음과 같은 에러가 발생할 수 있습니다. Annotation Processing 활성화 관련 문제 입니다.error log에 다음과 같은 메시지가 출력 됩니다.12345Annotation processing seems to be disabled for the project &quot;&lt;project name&gt;&quot;.For the plugin to function correctly, please enable it under&quot;Settings &gt; Build &gt; Compiler &gt; Annotation Processors&quot; intellij ide &gt; proferences &gt; build, excution, deploymont 탭 &gt; compiler &gt; annotation processors &gt; Enable annotaion procsssing 를 체크 하여 적용합니다.","link":"/2020/06/16/development/2018-09-12-IntellijLombok/"},{"title":"SVN 을 GIT 으로 이관하기 (git svn)","text":"SVN 으로 형상관리 하던 소스를 GIT으로 이전하기 위해서 포스팅을 정리해 봅니다. SVN을 오래 동안 써 왔고 큰 어려움이 없이 사용해 왔습니다. 단일 프로젝트를 주로 진행해 왔고 모듈을 나눠서 개발하다보면 GIT의 필요성을그다지 느끼기 어렵다고 생각합니다. 하지만 운영 되고 있는 서비스를 각각의 개발자가 신규 개발과 오류 수정하면서코드를 리펙토링 하기위한 활동 또는 신규 테스트를 위해서는 형상 관리의 유연성과 통합이 쉽게 이루어 져야 합니다. 비슷한 기능은 svn에서도 가능합니다.다만 같은 기능을 하더라도 빠르고 유연한 대처가 가능하다고 말씀 드리고 싶습니다.해당 포스팅은 svn 과 git은 설치 되었다는 전제로 진행합니다. 1. git-svn 설치 합니다.1$ sudo apt-get install git-svn 2. 이관하기 위한 환경이 되었는지를 확인합니다.1https://bitbucket.org/atlassian/svn-migration-scripts/src 사이트에서 다운받기1$ java -jar svn-migration-scripts.jar verify 명령어로 확인합니다.123Git: using version Subversion: using versiongit-svn: using version 준비된 상태이면 위와 같은 출력이 설치된 버전에 따라 보입니다. 3. svn 소스를 git 의 형태로 clone 합니다.1$ git svn clone 프로젝트svn주소 --no-metadata 프로젝트이름 이 과정 전에 다른 포스팅들에서는 사용자정보를 git 형태로 변환하는 과정들이 있습니다. 과정 중에 큰 이슈가 발생하지 않아 그대로 진행 했습니다.참고 페이지 링크 4. git 서버 repository를 생성합니다. git 서버에 .git 폴더를 생성하고 다음 명령어를 수행하여 레파지토리로 생성합니다.1$ git --bare init 5. git 의 remote 설정을 진행합니다.1$ git remote add origin 프로젝트git주소 remote 설정 6. git push1$ git push origin master 정상적으로 remote에 소스가 push 되었는지 확인합니다. 위 과정을 통해서 간단하게 svn으로 관리하는 소스를 git이로 이관하여 관리할 수 있습니다.","link":"/2020/06/16/development/2018-11-01-SvnToGit/"},{"title":"GIT SVN 관련 오류 ","text":"mac - git svn 사용시 sourcetree에서 push를 실행하면 발생하는 문제 해결123sudo mkdir /Library/Perl/5.18/autosudo ln -s /Applications/Xcode.app/Contents/Developer/Library/Perl/5.18/darwin-thread-multi‌-2level/SVN /Library/Perl/5.18/darwin-thread-multi-2levelsudo ln -s /Applications/Xcode.app/Contents/Developer/Library/Perl/5.18/darwin-thread-multi‌-2level/auto/SVN /Library/Perl/5.18/auto/참고 - stackoverflow 정상 구동되는 것을 확인하였다.","link":"/2020/06/16/development/2018-11-01-gitsvn/"},{"title":"Spring 4 MVC 에서 Swagger 설정하기","text":"REST API 서버를 구성하게 되면초기 설계와 변경되는 경우는 무수히 많습니다. 그때 마다 본래는 설계 문서를 변경하고 배포하는 것을수시로 이루어져야 하지만 실무에서 현실상 인력 구성이나내외부적인 요인으로 인해서 어려운 경우가 있습니다. 나중에 결국 문서 조차 맞지 않아서 오히려 혼란을 가중 시키는 경우도 존재합니다.(문서는 부디 최신화합시다.) 그리고 테스트에 있어도 일일히 API의 파라미터나 맵핑 값을확인해서 POSTMAN 활용하는 등 조금은 번거로운 경우가 발생합니다. 이와 같은 경우 Swagger를 사용해 보시길 바랍니다. 포스팅은 Spirng 4 MVC 에 Maven 기준입니다.(SpringBoot jpa 포스팅이 많은 관계로…) 1. Controller 에 annotation 이 있어야 합니다.1@RequestMapping(value=&quot;&quot;) 2. pom.xml 에 dependency 설정 추가합니다.1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; 3. mvc-config.xml 설정 추가합니다.12345&lt;bean id=&quot;swagger2Config&quot; class=&quot;springfox.documentation.swagger2.configuration.Swagger2DocumentationConfiguration&quot;&gt;&lt;/bean&gt;&lt;mvc:default-servlet-handler /&gt;&lt;mvc:resources location=&quot;classpath:/META-INF/resources/&quot; mapping=&quot;swagger-ui.html&quot;&gt;&lt;/mvc:resources&gt;&lt;mvc:resources location=&quot;classpath:/META-INF/resources/webjars/&quot; mapping=&quot;/webjars/**&quot;&gt;&lt;/mvc:resources&gt; 4. web.xml 에 sevlert 설정합니다.1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 루트가 열려있어야 controller에 접근이 가능하다. 5. swagger 에 접속하여 확인합니다.12swagger UI - http://localhost:8080/swagger-ui.htmlswagger Json doc - http://localhost:8080/v2/api-docs 이번 포스팅에서는 설정 방법에 대해서만 남깁니다. spring 3나 spring boot에 대한 포스팅이 대부분이라도움이 되셨으면 합니다.","link":"/2020/06/16/development/2018-11-02-swagger/"},{"title":"Jenkins 를 mac os 에 설치","text":"소프트 웨어 개발에 있어서 지속적인 통합 (CI - countinuous integration)을 제공하는 툴의 종류로 오픈소스이다. 다수의 인원이 개발을 하다보면 개발이나 또는 테스트 서버에 현재 개발 중인 소프트웨어를 배포하고 테스트 하는 환경이 지속적으로 이루어진다. 매번 한 개발자가 담당하여 진행하는 것도 소스의 양과 인원의 들의 코드 충돌 등의 문제를 해결하기 에는 한계가 있다. 이를 자동하기위 한 툴로 사용하는 것이 젠킨스 이다. 윈도우 환경에서는 설치 버전을 제공하여 사용였지만 맥에서는 사용 방법이 조금 달랐다. 먼저 homebrew 를 사용하여 젠킨스를 설치하여야 한다. Homebrew 설치 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Jenkins 설치1brew install jenkins Jekins 실행1brew services start jenkins Jekins 중단1brew services stop jenkins Jekins 포트변경1/usr/local/opt/jenkins/homebrew.mxcl.jenkins.plist파일의 –httpPort= 를 본인이 원하는 포트로 변경하여 사용하면 됩니다. 맥 자동 시작 시 사용하려면~/Library/LaunchAgents/ 로 파일을 복사하고 파일에12&lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt;로 설정하여 사용합니다.","link":"/2020/06/16/development/2018-09-26-mac-jekins/"},{"title":"SSH 를 비번 없이 사용하기","text":"Jenkins 자동화 빌드 배포를 하던 도중에 git 서버와연동하여 프로젝트를 빌드가 필요해서 진행 하던 도중에SSH 설정이 필요하다는 것을 알게됐습니다. SSH 설정 관련 해서는 다양한 포스팅이 있습니다.진행하면서 정리한 것을 간략하게 설명 하겠습니다. 1. 로컬 환경 .ssh 에서 rsa 키를 생성합니다.1ssh-keygen -t rsa이거 저거 물어보지만 특별한 디텍토리 위치나 재생성이 아니면엔터엔터엔터 id_rsa 와 id_rsa.pub 한 쌍이 생깁니다. 2. 서버로 사용하는 remote의 .ssh 폴더를 생성합니다.1ssh username@remoteIPorURL mkdir -p .ssh 3. remote 서버에 pub 키 authorized_keys 파일에 추가힙니다.1cat .ssh/id_rsa.pub | ssh username@remoteIPorURL &apos;cat &gt;&gt; .ssh/authorized_keys&apos;authorized_keys 에 퍼블릭 키를 추가 하는 방법은 수동 복사으로 복사하는 방법ssh-copy-id 을 활용하는 방법, scp 사용법 등이 있습니다. 진행하다가 키 문제인가 싶어서 다양한 방법을 찾고 실행해 보았습니다.제대로 하면 결국에는 다 같은 방법입니다. 4. 정상 접속을 확인합니다.1ssh username@remoteIPorURL 필수로 확인해야할 사항1. 폴더 권한폴더 권한이 유져 r 권한이 활성화 되어 있어야 합니다. 2. RSA 키 관리id_rsa 는 개인키이므로 관리에 주의를 요합니다. 2. macOS에서는 ROOT 권한에서 접근 되지 않습니다.새로운 사용자를 추가하고 그 유져의 권한으로 접근할 때는 SSH를 rsa 인증을 허용하지만ROOT 권한은 여러 방법을 동원해도 안되더군요. 비번을 치는 방법은 잘됩니다. 저는 이분에서 많은 시간을 소모 했습니다.macOS의 특징이겠거니 미루어 짐작해 봅니다. 방법을 아시는분은 첨언 부탁드립니다. 그럼 도움이 되셨으면 합니다.","link":"/2020/06/16/development/2018-11-07-ssh/"},{"title":"oracle 명령어와 동일한 mysql 명령어","text":"1. 공백치환 함수 ( NVL -&gt; IFNULL )Oracle : SELECT NVL(‘컬럼명’, ‘’) FROM DUAL;MySql : SELECT IFNULL(‘컬럼명’, ‘’) FROM DUAL; 2. 현재 날짜시간Oracle : SYSDATEMysql : NOW() 3. 날짜포멧Oracle : TO_CHAR(sysdate,’MMDDYYYYHH24MISS’)Mysql : DATE_FORMAT(now(),’%Y%m%d%H%i%s’) -&gt; 여기서 대문자Y는 4자리 년도, 소문자 y는 2자리 년도 4. 날짜 포멧 : 요일Oracle : 요일이 17로 인식함 -&gt; TO_CHAR(SYSDATE - 1, ‘D’)Mysql : 요일이 06으로 인식 -&gt; DATE_FORMAT(DATE_SUB(NOW(), INTERVAL 1 DAY), ‘%w’) 5. Like절 ‘%’ 사용법Oracle : Like ‘%’||’문자’||’%’ 이런식으로 컬럼명 앞뒤로 ‘%’Mysql : LIKE CONCAT(‘문자’,’%’) 이런식으로 CONCAT 함수 사용 6. 형변환Oracle : To_char, To_number 등Mysql : CAST 12345678Value DescriptionDATE Converts value to DATE. Format: &quot;YYYY-MM-DD&quot;DATETIME Converts value to DATETIME. Format: &quot;YYYY-MM-DD HH:MM:SS&quot;TIME Converts value to TIME. Format: &quot;HH:MM:SS&quot;CHAR Converts value to CHAR (a fixed length string)SIGNED Converts value to SIGNED (a signed 64-bit integer)UNSIGNED Converts value to UNSIGNED (an unsigned 64-bit integer)BINARY Converts value to BINARY (a binary string) 7. ROWNUMOracle : where 절에 rownum &gt; 5 and rownum =&lt; 10Mysql : where절 없이 limit 5,10 8. Sequence(시퀀스)는 둘 다 사용자함수를 만들어서 아래와 같이 사용Oracle : 시퀀스명.nextvalMysql : 시퀀스명.currval 9. 문자열 자르기Oracle: SUBSTR(문자열, 1, 10)Mysql: SUBSTRING(문자열, 1,10), LEFT(문자열, 3), RIGHT(문자열, 3) 10. 문자열 합치기Oracle: 문자열(또는 컬럼) || ‘’Mysql: CONCAT(문자열(또는 컬럼), ‘’)","link":"/2020/06/16/development/2018-11-21-OracleMysql/"},{"title":"Gitlab 설치하기(Docker on Mac)","text":"Github와 Gitlab 모두 클라우드를 지원하고 있다.다른 설치 없이 가입 레파지토리 생성을 통해 사용할 수 있다. 자체적으로 Git을 관리하고 있던 것을 서버로 관리하고 코드리뷰를원할하게 하고 싶은 욕구가 생겨서 Gitlab을 설치하고자 했다. Gitlab 공식 홈페이지 에서 가이드를 제공하고 있다. 하지만 정상적으로 작동되지 않았다. 현재 사용하고 있는 개발 서버가 맥이기 때문일지도 모르겠지만 다른 방법을 서칭해서 Docker에 gitlab을 설치 하는 방법으로 전환하였다. Docker 는 이곳 에서 다운 받아 설치할 수 있다.가입과 로그인은 개별적으로 하자. 다음과 같이 커멘드를 수행한다. 1234567docker run --detach --name gitlab \\ --hostname gitlab.local \\ --publish 30000:30000 \\ --publish 30001:22 \\ --env GITLAB_OMNIBUS_CONFIG=&quot;external_url &apos;http://gitlab.local:30000&apos;; gitlab_rails[&apos;gitlab_shell_ssh_port&apos;]=30000;&quot; \\ gitlab/gitlab-ce:9.1.0-ce.0 publish port 와 external_url 은 개인에 맞게 설정하자. 해당 커멘드가 오류 없이 수행되면 docker images에 gitlab서버가 수행 중일 것이다. http://gitlab.local:30000 에 접속하면 깃렙 로그인 화면을 확인할 수 있다.","link":"/2020/06/16/development/2019-03-29-GitlabServer/"},{"title":"Java IP address 사용하기","text":"정적으로 지정된 IP를 개발자들의 IP에 맞게 동적으로 할당되도록 프로그램을 수정하던 도중에 사용한 클래스에서 이상한 아이피가 할당되는 것을 확인하게 되었습니다. InetAddress Class 내부를 살펴보면 hostname 이 “localhost” 일 때만 정확한 IP를 리턴 하도록 구현되어 있었습니다. 123456String ip = &quot;&quot;;try{ ip = InetAddress.getLocalHost().getHostAddress();}catch(UnknownHostException e){ e.printStackTrace();} 유닉스와 리눅스 계열에서 hostname 이 사용자에 따라 동적으로 바뀌면서 IP가 제대로 할당되지 않는 것이 원인이었습니다. 아래와 같이 코드를 수정하였습니다. 1234567891011121314151617181920212223242526272829String ip= &quot;&quot;;try { Enumeration&lt;NetworkInterface&gt; nienum = NetworkInterface.getNetworkInterfaces(); while (nienum.hasMoreElements()) { NetworkInterface ni = nienum.nextElement(); Enumeration&lt;InetAddress&gt; kk= ni.getInetAddresses(); while (kk.hasMoreElements()) { InetAddress inetAddress = kk.nextElement(); if (!inetAddress.isLoopbackAddress() &amp;&amp; !inetAddress.isLinkLocalAddress() &amp;&amp; inetAddress.isSiteLocalAddress()) { ip = inetAddress.getHostAddress().toString(); } } }} catch (SocketException e) { e.printStackTrace();}네트워크 인터페이스에 할당된 서버 주소를 할당하도록 소스를 수정하여 맥이나 리눅스에서도 고유 아이피를 정상적으로 리턴하도록 하였습니다.","link":"/2020/06/16/development/2019-06-12-javaIPAdress/"},{"title":"Linux 명령어(top, free, grep option) ","text":"1. 시스템의 메모리 정보 파일 출력1cat /proc/meminfo 2. 시스템 프로세스 상세 내용보기윈도우의 작업 관리자와 비슷한 형태를 띈다. 1top 출력 내용 상세 설명 [PID] : 프로세스 ID[USER] : 프로세스를 실행시킨 사용자 ID[PR] : 프로세스의 우선순위[NI] : NICE 값, 마이너스를 가지는 값이 우선순위가 높음[VIRT] : 가상 메모리의 사용량(SWAP+RES)[RES] : 현재 페이지가 상주하고 있는 크기[SHR] : 가상 메모리 중 사용중인 메모리를 제외한 잔여 가상 메모리[S] : 프로세스의 상태[%CPU] : 프로세스가 사용하는 CPU의 사용률[%MEM] : 프로세스가 사용하는 메모리의 사용률[TIME+] : 프로세스가 CPU를 사용한 시간[COMMAND] : 실행된 명령어 SHIFT + M 메모리 사용률 정렬SHIFT + N PID 기준 정렬SHIFT + P CPU 사용률 정렬SHIFT + T 실행시간 기준 정렬SHIFT + R 정렬 기준변경 3. 메모리 모니터링1free -m 4. 디스크 모니터링1df [-h] : 용량을 읽기 쉽게 단위를 계산하여 출력[-T] : 파일 시스템 종류와 함께 디스크 정보 출력 5. grep option1grep -E, –extended-regexp : 확장 정규표현식으로 패턴을 해석한다(=egrep 같은 의미)-F, –fixed-strings : newline으로 분리된 고정된 문자열의 리스트로써 패턴을 해석한다","link":"/2020/06/16/development/2018-11-22-LinuxCommand2/"},{"title":"Gradle Build 오류(javax.net.ssl.SSLException)","text":"Sprigboot 에서 Gradle 빌드 수행 1javax.net.ssl.SSLException:closing inbound before receiving peer&apos;s close_notify 데이터베이스에 SSL설정이 되어 있지 않아 Springboot gradle 빌드시 발생하는 오류라고 합니다. jdbc url 에 다음고 같이 옵션을 추가해 주면 빌드가 정상적으로 수행되는 것을 확인 하였습니다. 1ex) jdbc:myslq://localhost:3306?&amp;useSSL=false","link":"/2020/06/16/development/2019-06-13-gradleBuildErorr/"},{"title":"Intellij Tomcat 로그 한글깨짐 현상 ","text":"Intellij 의 tomcat 로그 중 한글이 깨지는 현상 Intellij의 오른쪽 상단 EditconfigurationConfiguration 의 VM options에 다음 코드 추가 1-Dfile.encoding=UTF-8","link":"/2020/06/16/development/2019-07-09-intellijTomcatConfig/"},{"title":"SpringBoot + Rest Docs + Gradle","text":"API를 지속적으로 수정하면서 문서를 수정하는 데는 한계점 있습니다. Spring 개발하면서 UI와 함께 간략하게 제공되는 Swagger 와 REST docs가 대표적 입니다. Spring 프레임웍으로 개발하면서 Swagger를 사용해 보았고 이번 개발에는 REST docs를 적용해 보기로 했다. 구글링을 통해 여러 블로그를 찾아서 세팅을 진행 해보았지만 안되는 부분은 Spring REST Docs 사이트가 가장 명확하게 가이드를 하고 있으니 참고 하셨으면 합니다. Swagger와의 차이는 테스트 코드를 작성해서 문서를 생성해야 한다는 차이가 있습니다. 테스트 코드로 개발의 정합성을 향상하는 데 큰 도움이 될것으로 생각 됩니다. 현재의 개발환경은 Springboot Mybatis Gradle 을 활용하고 있습니다. 간략하게 세팅해야 하는 부분은 다음과 같습니다. build.gradle 추가 test code 작성 adoc 생성 html 생성","link":"/2020/06/16/development/2019-07-11-springbootRestDocsGradle/"},{"title":"웹 개발자에게 추천하는 맥 어플리케이션","text":"맥을 세팅 하면서 나에게 가장 유용 했었던 개발용 앱을 정리해 보겠다. Chrome 취향 이겠지만 개인적으로 크롬의 다양한 익스텐션들은 크롬을 사용하게 만든다. 그리고 기타 서비스의 연계 등이 Safari 다는 크롬을 켜게 한다. (물론 취향이다) Magnet App Store에서 2500원 하는 유료앱 화면 정리 나누기 기능 등을 제공한다. 사용해 보면 유용함을 알게 되는 유용한 앱이다. 화면 분할을 자유롭게 해야하는 분이라면 돈이 아깝지 않은 앱이다. Iterm2 터미널을 다루는 개발자에게 다크함(?)보다는 다양한 색을 제공 그리고 편의 기능을 제공하는 터미널 앱이다. vscode JS를 사용하면서 가장 좋은 앱을 찾다가 알게된 MS에서 제공하는 IDE 이제는 너무나 유명하다. 가벼움 다양한 익스텐션 기능 등 을 제공한다. 모든 기능은 무료다. Notion 메모 , 체크 리스트, 기록, TODO 리스트 등 정말 다양한 기능을 제공하고 md을 기반으로 공유하기 등의 다양한 기능을 제공한다. Jetbrain intelij , datagrip, webstorm, pycharm 등등 어떤 IDE와 비교할 수 없는 다양한 기능을 제공한다. 특히 코드내에 Defination 기능은 어느 IDE도 따라 올수 없다. 그리고 리펙토링 기능은 가끔 더 나은 패턴을 고민하게 만든다. 다만 가격이 조금 사악 하다는 단점이 있다. Slack 채팅 앱, 웹과 모바일을 모두 지원한다. 개발자의 대부분의 커뮤니티 들은 대게 슬렉 채널을 운영한다. Trello 협업을 위한 보드를 관리하기에는 이 앱보다 좋은 앱은 없다. 슬렉과의 연계와 다양한 기능을 제공한다.","link":"/2020/06/16/development/2020-02-25-forMap/"},{"title":"Array.prototype Map() Reduce()","text":"Javascript의 Array.prototype 두가지 for을 사용하지않고 Array 형태의 Object를 제어 Array.prototype.map()1234567891011/*map() 메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환합니다.*/const array1 = [1, 4, 9, 16];//array.map(element )const map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32]기본 적인 설명 외에도 Array의 각 요소를 if(조건문) 이나 기타 로직을 통해서 필요한 배열로 반환하고 싶다면 활용 아래처럼 인덱스와 함께 활용도 가능 12345678const array1 = [1, 4, 9, 16];const map1 = array1.map((element, index) =&gt; { console.log(element, index); return element;});console.log(map1); Array.prototype.map()12345678910const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15accumulator 기능을 활용하여 누산기능으로 활용하나 다양한 활용법이 있다. 중복의 제거1234567891011121314let arr = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];let result = arr.sort().reduce((accumulator, current) =&gt; { const length = accumulator.length if (length === 0 || accumulator[length - 1] !== current) { accumulator.push(current); } return accumulator;}, []);console.log(result); //[1,2,3,4,5]/*동일기능*/let result = Array.from(new Set(arr)); reduce로 map, filter, find 모두 구현가능12345678910111213141516171819202122232425262728293031let arr = [9, 2, 8, 5, 7]let sum = arr.reduce((pre, val) =&gt; pre + val)console.log(sum) // 31// mapvar arr = [&apos;foo&apos;, &apos;hello&apos;, &apos;diamond&apos;, &apos;A&apos;]var arr2 = arr.reduce((pre, value) =&gt; { pre.push(value.length) return pre}, [])console.log(arr2) // [3, 5, 7, 1]// filtervar arr = [4, 15, 377, 395, 400, 1024, 3000]var arr2 = arr.reduce((pre, value) =&gt; { if (value % 5 == 0) { pre.push(value); } return pre;}, []);console.log(arr2) // [15, 395, 400, 3000]// findvar arr = [4, 15, 377, 395, 400, 1024, 3000]var arr2 = arr.reduce((pre, value) =&gt; { if (typeof pre == &apos;undefined&apos; &amp;&amp; value % 5 == 0) { pre = value; } return pre;}, undefined);console.log(arr2) // 15 참고링크https://velog.io/@decody/map-%EC%A0%95%EB%A6%AC","link":"/2020/06/16/development/2020-06-15-JSMapReduce/"},{"title":"JS String.prototype","text":"JS String.prototype 중 유용한 몇가지 정리 String.chartAt() 인덱스의 character 리턴만약 인덱스가 문자열 길이보다 큰 경우 빈 문자열 “ “ 을 리턴 123456const sentence = &apos;I want to be a nice person&apos;;const index = 4;console.log(`The character at index ${index} is ${sentence.charAt(index)}`);//The character at index 4 is n String.split()str.split([separator[, limit]]) 문자열을 구분자를 이용하여 배열로 리턴 인덱스를 넣어 limit 123456789const sentence = &quot;I want to be a nice person&quot;;const array1 = sentence.split(&quot; &quot;);console.log(array1);//[&quot;I&quot;, &quot;want&quot;, &quot;to&quot;, &quot;be&quot;, &quot;a&quot;, &quot;nice&quot;, &quot;person&quot;]const array2 = sentence.split(&quot;&quot;, 3);console.log(array2);//[&quot;I&quot;, &quot; &quot;, &quot;w&quot;] String splice()str.slice(beginIndex[, endIndex])index를 지정하여 문자열을 리턴 12345678910111213const str = &apos;The quick brown fox jumps over the lazy dog.&apos;;console.log(str.slice(31));// expected output: &quot;the lazy dog.&quot;console.log(str.slice(4, 19));// expected output: &quot;quick brown fox&quot;console.log(str.slice(-4));// expected output: &quot;dog.&quot;console.log(str.slice(-9, -5));// expected output: &quot;lazy&quot; 참조 페이지 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/","link":"/2020/06/23/development/2020-06-16-JSStringPrototype/"},{"title":"개발에 공부에 도움이 되는 사이트 모아보기","text":"개발에 관련되서 강의나 사이트가 수도 없이 많은 만큼 옥석을 가리는 것도 그만큼 중요한 일이 되었다. 개인적으로 도움이 되었던 사이트를 소개한다. - 노마드코더 *****- 노마드코더유튜브채널 *****크리에이터인 린과 개발자 니콜라스 두분이 운영하는 아케데미 이미 웹프로그래밍을 익히고 배우려는 사람들 사이에서는 입소문이 나 있는 곳이다. 웹 기술은 빠르게 발전하고 있다. 이 곳은 그에 맞춰서 트랜디한 정보를 자주 업데이트 하고 있다. 단순히 언어를 가르치는 컨텐츠보다 무엇을 만들어 내는 과정과 재미를 느끼게 하는 컨텐츠를 가지고 있다. 정형화된 개발 스타일 보다는 힙한 스타일의 코딩과 교육을 즐기고자 한다면 개인적으로 국내에서는 노마드코더 그 이상 추천할 곳은 없다. 영어를 잘한다면 수업을 자막없이 들을 수 있어 영어 듣기 정도는 자동으로 되는 장점은 덤이다.다양한 오프라인 모임과 무료 아카데미 프로그램도 활발하게 운영 중이다. 앞으로가 더 기대되는 곳이다. - 생활코딩 ****개발관련해서 공부를 시작한 국내 사람이라면 한번쯤은 들어가본 사이트가 아닐까? 이고잉님이 운영하고 계신 개발 교육 사이트 이다. 개인적으로는 web1 강의를 보고 내가 아는 식을 제대로 알고 깊게 알고 있는지에 대해서 다시 한번 생각해보는 기회가 되었다. 기초적인 개념의 이해와 언어 프레임웍까지 요즘에는 추가 되고 있고 모두 무료로 제공된다. 코딩야학이란 스터디 등 교육프로그램도 운영 중이다. - 엔지니어대한민국 YouTube채널 ***알고리즘 관련하여 찾아다가 우연히 알게된 유툽채널 이다. 알고리즘에 필요한 이론과 코딩을 속도감 있고 명료하게 설명한다. 직접 코드를 구현하는 코드는 무엇보다 깔끔하다. 자바로 코드는 구성되어 있고 객체지향성이 눈에 띈다. 정말 훌륭한 채널이지만 더 이상 영상이 올라 오고있지 않아서 아쉬운 곳 이다. - Wikidocs ***온라인 책 제작 공유사이트(개발관련 서적이 다수) 점프투 파이썬, 점프투 자바 등등 - 인프런 ***양질의 무료강의와 유료강의 등을 제공하는 교육 사이트이다. 요즘 들어 책의 저자분들이 인프런에서 자신의 강의를 런칭하고 있다. - BOJ기초부터 고급까지 방대한 문제, 커뮤니티가 활성화 되어 있어 질문하기 좋은 곳이다. 국내에서는 가장 많은 문제를 제공하는 곳이다. - 프로그래머스동영상 강의 및 알고리즘연습 환경을 제공한다. 여러 IDE와 비슷한 환경을 제공하는 편의와 인터페이스와 문제양보다는 컨텐츠와 질이 좋은 곳이다.","link":"/2019/11/01/development/studySite/"},{"title":"1만시간의재발견","text":"“ 1만시간의 법칙 “ 대게 어떤 일에 대성하기 위해서는 1만시간이 투자된다라는이론으로 널리 알려져 있는 것으로 알고 있다. 나 또한 어딘가에서 들어본 이야기. 사람들은 1만시간의 법칙에서 대부분 시간에 초점을 맞춘다.저자들은 시간 보다 방법에 대해 강조한다. 그리고 책의 대부분의 내용은 “의식적인 연습” 이라는 내용에 대해 쓰여져있다.의식적인 연습을 위해서 다양한 방법을 제시하고 있다. 제시된 방법 중에 몇가지 인상적인 부분은 선천적인 재능보다 제대로된 연습과 훈련을 통해서 어떤 분야에서든잠재능력을 키우고 발전해 나아갈 수 있다는 점이다. 어느 선까지 양(시간)을 투자 했을 때 발전의 한계가 있고이를 넘어서기 위해서는 분명한 방향이 있는 올바른 훈련 이에 따른 피드백이 필요하다는 것이다. 개인적으로 생각했던 부분과 일치하는 부분이 많아 책을 읽는 동안신기하다고 여기게 되었다. 분명한 목표, 올바른 훈련, 부족한 부분과 방해되는 요소이 발견 그리고 지속하는 힘 제대된 시간 활용만큼 중요한 건 없다고 여기는 요즘이다.제대로 된 시간 즐기는 사람이길 저자안데르스 에릭슨 : 1만시간의 법칙 의 이론의 심리학자로버드 풀 : 사이언스, 네이처 등의 매체의 글을 남긴 저널리스트","link":"/2019/11/27/lifestyle/1%EB%A7%8C%EC%8B%9C%EA%B0%84%EC%9D%98%EC%9E%AC%EB%B0%9C%EA%B2%AC/"},{"title":"진정한 프로그래머?","text":"“Programming Doesn’t Require Talent or Even Passion” 라는 글을 일게되면서 나의 생각을 정리한다. 원문번역 프로그래밍을 하면서 어쩌면 최소한 열정은 무조건 가진 사람이어야 한다고 믿고 있었는 지도 모르겠다. 사실 우리 모두는 그렇게 대단한 사람이 될 필요는 없는 것이다. 적당한 재능과 적당한 열정만 있더라도 상관없다. 하지만 최소한 왜 하는 지는 생각하는 개발자가 아닌 사람이으로 살아갔으면 한다.","link":"/2019/11/12/lifestyle/justThink/"},{"title":"개발에 공부에 도움이 되는 사이트 모아보기","text":"- 노마드코더 *****- 노마드코더유튜브채널 *****크리에이터인 린과 개발자 니콜라스 두분이 운영하는 아케데미 이미 웹프로그래밍을 익히고 배우려는 사람들 사이에서는 입소문이 나 있는 곳이다. 웹 기술은 빠르게 발전하고 있다. 이 곳은 그에 맞춰서 트랜디한 정보와 기술을 끊임없이 업데이트 하고 있다.단순히 교육을 위한 컨텐츠보다 무엇을 만들어 순수한 개발에 대한 흥미와 탐구심으로 가득차있다. 정형화된 개발 스타일 보다는 힙한 스타일의 코딩과 교육을 즐기고자 한다면 개인적으로 국내에서는 노마드코더 그 이상 추천할 곳은 없다. 영어를 잘한다면 수업을 자막없이 들을 수 있어 영어 듣기 정도는 덤이다. 물론 한국어 자막을 지원하는 곳이니 쫄지 말자. 다양한 오프라인 모임과 무료 아카데미 프로그램도 활발하게 운영 중이다. 앞으로가 더 기대되는 곳이다. - 생활코딩 ****웹 개발관련해서 공부를 시작한 국내 사람이라면 한번쯤은 들어가본 사이트가 아닐까? 이고잉님이 운영하고 계신 개발 교육 사이트 이다. 개인적으로는 web1 강의를 보고 내가 아는 지식을 제대로 아는 것이 중요하다는 생각을 다시 한번 하게되었다. 기초적인 개념의 이해와 언어 프레임웍까지 요즘에는 추가 되고 있고 모두 무료로 제공된다. 코딩야학이란 스터디 등 교육프로그램도 운영 중이다. - 엔지니어대한민국 YouTube채널 ***알고리즘 관련하여 찾아다가 우연히 알게된 유툽채널 이다. 알고리즘에 필요한 이론과 코딩을 속도감 있고 명료하게 설명한다. 직접 코드를 구현하는 코드는 무엇보다 깔끔하다. 자바로 코드는 구성되어 있고 객체지향성이 눈에 띈다. 아마도 코딩 인터뷰 준비 중에 채널을 운영하신게 아닌가 싶다. 더이상 영상이 올라오지 않아 아쉬운 곳이다. - 인프런 ***양질의 무료강의와 유료강의 등을 제공하는 교육 사이트이다. 요즘 들어 유명책의 저자분들이 인프런에서 자신의 강의를 런칭하고 홍보도 활발한 곳이다. - BOJ알고리즘을 공부하려는 사람이라면 백준을 한번쯤은 들리게 되기 마련이다. 국내에서는 가장 많은 문제를 제공하는 곳이다. 또한 슬렉채널도 유용하다고 한다(?) - 프로그래머스동영상 강의 및 알고리즘연습 환경을 제공한다. 여러 IDE와 비슷한 환경을 제공하는 편의와 인터페이스와 문제양보다는 컨텐츠와 질이 좋은 곳이다.","link":"/2019/11/01/lifestyle/studySite/"},{"title":"2020년 독서목록","text":"나는 회사체질이 아니라서요 : 서메리 - 번역가로 활동 중인 서메리의 프랜서 도전기 부의 본능 : 브라운 스톤 - 재테크 관련 서적 많은 곳에서 추천해줬던 책 자바의 정석 : 남궁성 - 자바 언어 기초 오랜만에 읽어보는 자바 기본서","link":"/2020/02/09/lifestyle/%EB%8F%85%EC%84%9C%EB%AA%A9%EB%A1%9D2020/"},{"title":"독서목록","text":"2019년 한번에 집히는 대로 여러권을 동시에읽는 방법으로 올해에는 독서 해보고 있다. 읽다가 흥미가 떨어지는 책은 그냥 놓았다.예전 처럼 의무로 읽는 다는 게 피곤한 일이다. 그러다보니 중간에 놓은 책들도 많다. 번호 제목 구분 분류 비고 1 작은부자로 사는법 경제 일반 2 그림으로 개념을 이해하는 알고리즘 개발 알고리즘 3 코드컴플릿트 개발 일반 4 나는 오늘부터 경제기사를 읽기로했다 경제 상식 5 부의 추월차선 경제 방법론 6 운이 풀리는 말버릇 자기개발 방법 7 후천적부자들 경제 투자 8 그림으로 정리한 알고리즘과 자료구조 개발 알고리즘 9 행복한프로그래밍 개발 일반 10 Vue.js 입문 개발 언어 11 HTTP 완벽가이드 개발 네트워크 12 Effective Java 개발 방법론 13 처음배우는 스프링부트 개발 프레임워크 14 도난당한패스워드 개발 보안 15 부자아빠가난한아빠1 경제 일반 16 부자아빠가난한아빠2 경제 일반 17 디자인 씽킹 바이블 경제 마케팅 18 블록체인 혁명 경제 상식 19 나의 월급 독립프로젝트 경제 투자 20 돈이되는 아파트 돈이 안되는 아파트 경제 투자 21 탑코더알고리즘 개발 알고리즘 22 돈 뜨겁게 사랑하고 차갑게 다루어라 경제 투자 23 투자는 심리게임이다 경제 투자 24 인스파이어드 개발 제품관리 25 1만시간의 재발견 자기개발 방법론 26 토비의스프링 개발 프레임워크 ing 27 크리에이티브는 단련된다 자기개발 광고/마케 28 트렌드코리아 2020 일반 트랜드 ing 29 1일 1짠 돈습관 경제 방법 30 나는 아마존에서 미래를 다녔다 일반 IT 관련 31 창업 오늘 안하면 내일도 못한다 경제 창업 32 술 잡학사전 일반 상식 33 스프링부트 2 개발 프레임워크 34 불량헬스 일반 운동 35 90년생이 온다 경제 경영 책을 읽기만 한다고 지식이 깊어지진 않는다.그냥 글을 읽기만 할뿐… 정리하고 지식을 소화하자.","link":"/2019/11/01/lifestyle/%EB%8F%85%EC%84%9C%EB%AA%A9%EB%A1%9D/"},{"title":"트렌드 코리아 2020","text":"트랜드 코리아 매년 트렌드를 리서치를 통해서 예상 키워드를 뽑아 그 정보를 책으로 구성하는 책이다.2020년 다가오는 트랜드로 예상되는 키워드를 간단히 정리해본다. 멀티페르소나 나 자신을 뜻하는 myself 가 myselves 로 변하고 있다. 다양한 상황에서 현대 소비자는 매순간 변신한다. 이를 학술적으로 페르소나라 지칭한다. 다원성 확장되고 있지만 역설적으로 정체성 기반은 매우 불안정해 지고 있다. 라스트핏 이코노미 고객 접점의 배송, 이동, 구매 로 이어지는 활동에서 이전의 성능과 품질, 가격 경쟁만이 아니라 소비자가 만족하는 서비스의 질이 경쟁력을 가지는 시대로 변해가고 있다. 페어플레이 현재 한국 사회에서의 공정성의 대한 열망이 커지고 있다는 것은 누구나 느끼고 있을 것이다. 스트리밍라이프 영상, 음악, 책 뿐만이 아니라 렌탈에서 이어지는 모든 것들을 소유가 아닌 스트리밍으로 즐기는 시대이다. 그만큼 스트리밍 라이프는 노마드 라이프를 실현하고 자하는 현대인에 요구에 맞춰 변화하고 있다. 초개인화 기술 소비자를 타겟팅할 때의 세그먼트는 이제 0.1에 가까워지고 있다. 개인들에게 단순한 개인화로는 다양한 니즈를 만족시키에는 부족하여 초개인화 기술이 주요해지고 있다. AI와 데이터터 예측 등의 기술 발전으로 이를 더욱 가속화 되고 있다. 팬슈머 팬 + 컨슈머 / ‘내가 키웠다’ 라는 말이 점차 늘고 있다. 단순한 소비자에 머물지 않고 관심을 가지고 소비가 아닌 관여에 초점을 맞춰진 소비 트랜드가 구축되고 있다. 특화생존 차별화가 아닌 특별화 정말 특화해야 생존할 수 있다. 적자 생존이 아닌 특화 생존. 애자일적인 방법으로 접근한 마이크로 매니징이 이루어질 것이다. 오팔세대 OPAL(Old PeoPle with Active Lives), 베이비부머를 대표하는 58년 개띠를 의미하는 키워드다. 퇴직 이후의 사회, 소비 생활 등 주목 받고 있는 소비자 들이다. 편리미엄 편리함 + 프리미엄 바쁘게 살아가는 현대인들에게 시간의 빈곤과 귀찮음의 해결은 무엇보다 중요하다. 이를 해결해주는 플랫폼 들을 주목해야 한다. 업글인간 성공보다 성장을 중시하고 나아가 자신을 중요시 하는 미코노미의 소비자들은 먼 미래보다 지금의 나은 내일의 나를 목표로 살아간다. 신뢰가 가는 지식을 가공하여 제공하는 서비스들을 주목할만 하다. 트랜드 코리아를 읽고 전반적으로 개개인의 다양성이 더욱 중요하게 여기는 사회가 되어 가고 있지 않을까 싶다.다양한 목소리가 다양한 그룹을 만들고 각각의 성향을 대변하는 일들이 점차 많아지고 있다. 그만큼 색깔을 지닌 사람이 되는 것도 참 중요하지 않을까 싶다. 새해 전에 가볍게 읽어보기 좋은 책이다.","link":"/2019/12/04/lifestyle/%ED%8A%B8%EB%9E%9C%EB%93%9C%EC%BD%94%EB%A6%AC%EC%95%842020/"},{"title":"Sort","text":"1. Bubble Sort버블정렬은 두 인접한 원소의 크기를 비교하여 정렬하는 방법 O(n) 123456789101112131415function bubble(arr) { let result = arr.slice(); for (let i = 0; i &lt; result.length - 1; i++) { // 한번 순외하면 result 가장 끝에 큰수가 정렬되므로 -i for (let j = 0; j &lt; result.length - i; j++) { if (result[j] &gt; result[j + 1]) { let temp = result[j]; result[j] = result[j + 1]; result[j + 1] = temp; } } } return result;} 2. Merge Sort 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.12345678910111213141516171819202122232425262728293031323334function mergeSort(arr) { if (arr.length &lt;= 1) return arr; const mid = Math.floor(arr.length / 2); const left = arr.slice(0, mid); let right = arr.slice(mid); return merge(mergeSort(left), mergeSort(right));}function merge(left, right) { let result = []; while (left.length &amp;&amp; right.length) { if (left[0] &lt; right[0]) { result.push(left.shift()); } else { result.push(right.shift()); } } while (left.length) { result.push(left.shift()); } while (right.length) { result.push(right.shift()); } return result;}let arr = [4, 1, 5, 3, 2, 6, 7];console.log(arr);console.log(mergeSort(arr)); 3. Quck Sort기준값을 두고 작으면 왼쪽 크면 오른쪽으로 이동시키는 것을 반복한다. 123456789101112131415161718192021unction quckSort(arr) { if (arr.length &lt;= 1) return arr; let pivot = arr[0]; let left = []; let right = []; for (let i = 1; i &lt; arr.length; i++) { if (pivot &gt; arr[i]) { left.push(arr[i]); } else { right.push(arr[i]); } } return quckSort(left).concat(pivot, quckSort(right));}const arr = [4, 1, 5, 3, 2, 6, 7];console.log(arr);console.log(quckSort(arr));","link":"/2020/06/22/algorithm/2020-06-22-sort/"},{"title":"JPA","text":"","link":"/2020/06/22/spring/2020-06-22-jpa/"}],"tags":[{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"MarkDown","slug":"MarkDown","link":"/tags/MarkDown/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"SVN","slug":"SVN","link":"/tags/SVN/"},{"name":"VSCODE, IDE","slug":"VSCODE-IDE","link":"/tags/VSCODE-IDE/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Etc","slug":"Etc","link":"/tags/Etc/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"VSCODE , IDE","slug":"VSCODE-IDE","link":"/tags/VSCODE-IDE/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"Intelij, IDE","slug":"Intelij-IDE","link":"/tags/Intelij-IDE/"},{"name":"GIT","slug":"GIT","link":"/tags/GIT/"},{"name":"Gitlab, Docker","slug":"Gitlab-Docker","link":"/tags/Gitlab-Docker/"},{"name":"study, develop","slug":"study-develop","link":"/tags/study-develop/"},{"name":"독서","slug":"독서","link":"/tags/%EB%8F%85%EC%84%9C/"},{"name":"Think","slug":"Think","link":"/tags/Think/"},{"name":"Study","slug":"Study","link":"/tags/Study/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"JPA","slug":"JPA","link":"/tags/JPA/"}],"categories":[{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"Lifestyle","slug":"Lifestyle","link":"/categories/Lifestyle/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"}]}